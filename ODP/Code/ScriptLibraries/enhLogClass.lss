'++LotusScript Development Environment:2:5:(Options):0:74
%REM ***************************************************************************
 ************************************************************************************
	enhLogClass Lotusscript Library

	Carrier for the EnhancedLog class.
	Copyright &copy; 2002 - 2052, Devin S. Olson
	http://www.azlighthouse.com

	Author: Devin S. Olson  (devin.olson@azlighthouse.com)
	http://www.devinolson.net
	Version 2021.12.15

	Last updated: 12/2021

 ************************************************************************************
%END REM *********************************************************************

%REM  Released under the Apache License, Version 2.0
	' ************************************************************************************
	' *  Copyright 2002 Devin S. Olson
	' *  
	' *  Licensed under the Apache License, Version 2.0 (the "License"); 
	' *  you may not use this file except in compliance with the License. 
	' *  You may obtain a copy of the License at 
	' *  
	' *  http://www.apache.org/licenses/LICENSE-2.0 
	' *  	
	' *  Unless required by applicable law or agreed to in writing, software 
	' *  distributed under the License is distributed on an "AS IS" BASIS, 
	' *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
	' *  See the License for the specific language governing permissions and 
	' *  limitations under the License. 
	' *  	
 	' ************************************************************************************
 	' ************************************************************************************
	' BEGIN NOTICE	
	' *	NOTICE
	' *		Enhanced Log 
	' *		Copyright (c) 2002 - 2052 Devin S. Olson.  All rights reserved.
	' *
	' *  Developed by: Devin S. Olson
	' *                azlighthouse works, llc.
	' *                http://www.azlighthouse.com
	' *  
	' *  Permission is hereby granted, free of charge, to any person obtaining a copy
	' *  of this software and associated documentation files (the "Software"), to
	' *  deal with the Software without restriction, including without limitation the
	' *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	' *  sell copies of the Software, and to permit persons to whom the Software is
	' *  furnished to do so, subject to the following conditions:
	' *  
	' *    1. Redistributions of source code must retain the above copyright notice,
	' *       this list of conditions and the following disclaimers.
	' *  
	' *    2. Redistributions in binary form must reproduce the above copyright
	' *       notice, this list of conditions and the following disclaimers in the
	' *       documentation and/or other materials provided with the distribution.
	' *  
	' *    3. Neither the names of Devin S. Olson, azlighthouse works, nor the names  
	' *       of its contributors may be used to endorse or promote products derived 
	' *       from this Software without specific prior written permission.
	' *  
	' *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
	' *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
	' *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE 
	' *  CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
	' *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
	' *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
	' *  WITH THE SOFTWARE.
	' *  
	' *  NOTICE TRANSLATION: 
	' *  	You can give away this code.  
	' *  	You can sell this code.  
	' *  	You can use this code in your programs, either to give away or to sell.  
	' *  	You can to whatever you want to do with this code, 
	' *  	AS LONG AS YOU CREDIT THE AUTHOR AND INCLUDE THE ABOVE LICENSE AND NOTICE.  
	' *  	It is very simple: don't be a jerk and claim that you wrote the code.
	' *	END NOTICE
 	' ************************************************************************************
%END REM

' Option Public 	' Intentionally removed
Option Explicit  

'++LotusScript Development Environment:2:5:(Forward):0:1
Declare Private Class enhLogListCarrier
Declare Private Class ProfiledMethod 
Declare Private Class ProfiledMethodList As enhLogListCarrier
Declare Private Class NestedProfiledMethodList As enhLogListCarrier
Declare Private Class NotesLink 
Declare Private Class EnhancedLogStackTrace 
Declare Private Class EnhancedLogEntry 
Declare Private Class EnhancedLogEntryBuffer
Declare Private Class Singleton 	' Declaring as Private allows for Singleton functionality.
Declare Public Class EnhancedLog 
Declare Sub Initialize
Declare Sub Terminate	
Declare Public Function enhLogGetLogConfigText(itemname$) As String
Declare Public Function enhLogArchiveDocuments (server$, filepath$, view$, max&, purge As Boolean, archived&, purged&) As Boolean
Declare Public Function enhLogProfileMethodFinish(ByVal classname$, ByVal operation$) As Double 
Declare Public Function stripHTML (source$, stripOrphans As Boolean) As String
Declare Private Function getServerFilepath (ByVal server$, ByVal filepath$) As String
Declare Public Sub enhLogCloseLog() 
Declare Private Sub InstantiateLoggingSession()
Declare Public Sub enhLogSetLogWarnings (source As Boolean)
Declare Public Sub enhLogSetUserNameAbbrev (source$)
Declare Public Function uiSelectDatabase(title$, msg$, fieldnameServer$, fieldnameFilepath$) As NotesDatabase 
Declare Public Sub enhLogReleaseVersionBuild() 
Declare Public Function strEndsWith(searchin$, searchfor$) As Boolean 
Declare Public Function enhLogStackTrace(prefix$, description$) As Boolean
Declare Public Sub enhLogSetActionsIncludeMethodNames (source As Boolean)
Declare Private Function getScalar(source As Variant) As Variant	
Declare Public Property Set enhLogOutputToNotesLog As Boolean 
Declare Public Function enhLogExceptionWithLink (prefix$, description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$) As Boolean
Declare Public Function enhLogGetCachedErrorTimestamp() As String
Declare Public Sub enhLogDumpContent (prefix$, filepath$)
Declare Public Sub enhLogSetResumeOnLoggingFailure (source As Boolean)
Declare Function getHashedValue(source$, clearCache As Boolean) As String
Declare Public Function enhLogAction(prefix$, description$) As Boolean
Declare Public Property Get enhLogOutputToNotesLog As Boolean 
Declare Public Function enhLogGetLogConfigUNID() As String
Declare Public Function enhLogGetCachedErrorExtended() As String
Declare Public Function getDocumentByUNID(ByVal universalID$) As NotesDocument 	
Declare Private Function getProfiledMethodXML(pm As ProfiledMethod, includeAll As Boolean) As String 
Declare Public Function enhLogGetProfiledMethodsXMLstream(includeAll As Boolean) As NotesStream 
Declare Public Function enhLogMethodResult (prefix$, description$) As Boolean
Declare Public Function getListSize(source As Variant) As Long 
Declare Public Function enhLogGetNotesLogForm() As String 
Declare Public Function enhLogGetTaggedTicks(tag$) As Double
Declare Public Function enhLogGetProfileMethodTriggerCount(source$) As Long 
Declare Public Sub enhLogSetOverwriteFile (source As Boolean)
Declare Public Function getListTags(source As Variant) As Variant  
Declare Public Function enhLogProfileMethodStart(ByVal classname$, ByVal operation$) As Double 
Declare Public Function enhLogWarningWithLink (prefix$, description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$) As Boolean
Declare Public Property Set enhLogContentToNotesLog As Boolean 
Declare Public Function getDbConfigDoc(ByVal source$, clearCache As Boolean) As NotesDocument
Declare Private Function checkCreateDirectory(root$, target$) As String 
Declare Public Function fileExists (filepath$) As Boolean
Declare Public Function enhLogGetTaggedMilliseconds(tag$) As Double
Declare Public Function enhLogTicksPerSecond() As Long 
Declare Public Function enhLogGetLogConfigDb() As NotesDatabase 
Declare Public Property Get enhLogContentToNotesLog As Boolean 
Declare Public Function isBlankString(source$) As Boolean 
Declare Public Sub enhLogSetUserName (source As NotesName)
Declare Public Function getScalarString(source As Variant) As String 
Declare Public Function enhLogHasCachedError() As Boolean
Declare Public Function safeEvaluate(ByVal formula$, context As Variant, failValue As Variant) As Variant
Declare Public Function enhLogTicksToMilliseconds(source#) As Double 
Declare Public Function enhLogExtendedContent (prefix$, description$, extendedcontent$) As Boolean
Declare Private Function createRichTextStyle (Bold As Boolean, Effects%, FontSize%, Italic As Boolean, NotesColor%, NotesFont%, PassThruHTML As Boolean, Strikethrough As Boolean, Underline As Boolean) As NotesRichTextStyle
Declare Public Function enhLogSave(force As Boolean, createResponse As Boolean)
Declare Public Function getEnhLog() As EnhancedLog 
Declare Public Function enhLogIsLogDisabled() As Boolean
Declare Private Function getLogOptionsProfile() As NotesDocument
Declare Public Function getConfigUNID(ByVal source$, clearCache As Boolean) As String
Declare Private Function isStringArrayEmpty (source As Variant) As Boolean
Declare Public Function enhLogGetLatestLog() As NotesDocument
Declare Public Function stripFirstSubstr (source$, searchfor$) As String
Declare Public Function enhLogHasErrors() As Boolean
Declare Function getDocItemText(source As NotesDocument, itemname$) As Variant
Declare Public Sub enhLogSetSendTo (source As Variant)
Declare Private Function getACLlevel(acl%) As String 
Declare Public Function getEmptyDocumentCollection (source As NotesDatabase) As NotesDocumentCollection
Declare Public Function enhLogGetSubject() As String
Declare Public Property Get FILEPATH_ENHANCEDLOG_FILE (prefix$) As String   
Declare Public Sub enhLogSetAutoSave (source As Boolean)
Declare Public Function enhLogGetCachedErrorCode() As Integer
Declare Public Function enhLogGetMethodTicks(ByVal classname$) As Double
Declare Public Function enhLogGetProgramName() As String
Declare Public Function enhLogResetDbLog() As Boolean
Declare Public Function enhLogException (prefix$, description$) As Boolean
Declare Public Function enhLogAppendAsDocLink (source As NotesDocument, fieldname$, linkcomment$, hotspottext$) As Boolean
Declare Public Function enhLogHasEntries() As Boolean
Declare Public Sub enhLogSetLogErrors (source As Boolean)
Declare Public Sub enhLogSetProgramName (source$)
Declare Private Property Get FILEPATH_DELIMITER As String   
Declare Public Sub enhLogAllDocItems (source As NotesDocument)
Declare Public Function enhLogGetCachedErrorMessage() As String
Declare Public Function enhLogGetConfigItemNames() As Variant 
Declare Public Sub enhLogSetSubject(source$)
Declare Public Function getOpenDatabase(server$, filepath$) As NotesDatabase
Declare Public Function enhLogWarning (prefix$, description$) As Boolean
Declare Public Function strBeginsWith(searchin$, searchfor$) As Boolean 
Declare Public Function getCurrentDb() As NotesDatabase
Declare Private Function enhLogOptionsProfileFieldNames() As Variant
Declare Public Function enhLogMethodResultWithLink (prefix$, description$, linkto As Variant, linkcomment$, HotSpotText$) As Boolean
Declare Public Function getFormPrefixForLogging(subform_prefix$) As String 
Declare Private Function generateLogDoc(acl%, ndb As NotesDatabase, username As NotesName, userroles As Variant, start As NotesDateTime, progname$, server$, title$, filepath$, subject$, notesversion$, resumeonfail As Boolean) As NotesDocument
Declare Public Function enhLogGetCachedErrorMethod() As String
Declare Sub enhLogInstantiateNotesLog() 
Declare Private Function getCallingUIobjectName() As String
Declare Public Sub TrimString (target$)
Declare Public Function strReplaceSubstring (source$, searchfor$, replacewith$) As String
Declare Public Sub enhLogSetCommonProperties(progname$, localEcho As Boolean, logActions As Boolean, logMethodResults As Boolean, logErrors As Boolean, logStackExceptions As Boolean)
Declare Public Sub enhLogSetLogActions (source As Boolean)
Declare Public Function enhLogCreateLog (programName$) As EnhancedLog
Declare Public Function enhLogGetCachedErrorLine() As Integer
Declare Function getEnvarName(source$, clearCache As Boolean) As String
Declare Public Function enhLogExtendedContentWithLink (prefix$, description$, extendedcontent$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$)  As Boolean
Declare Public Function enhLogGetLogConfigDoc(spawnNew As Boolean) As NotesDocument
Declare Public Function enhLogActionWithLink (prefix$, description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$) As Boolean
Declare Public Sub enhLogSetLocalEcho (source As Boolean)
Declare Public Function getCurrentSession() As NotesSession
Declare Public Sub enhLogSetLogStackExceptions (source As Boolean)
Declare Public Sub enhLogClearCachedError()
Declare Public Sub enhLogSetLogMethodResults (source As Boolean)
Declare Public Function enhLogIsProfilingEnabled() As Boolean 

'++LotusScript Development Environment:2:5:(Declarations):0:10

Private Const LIB_PREFIX = |Library: enhLogClass.|

%REM ***************************************************************************
 ************************************************************************************
	PRIVATE UTILITY CONSTANTS  
 ************************************************************************************
%END REM *********************************************************************
Private Const ELEMENT_UNKNOWN = 		|Notes: Programmable Element Unknown|

Private Const DEFAULT_DELIMITER = 		|Ø|

Private Const FILEPATH_LOGS_DEFAULT = 	|logs|
Private Const FORMAT_TIMESTAMP = 		|yyyy/mm/dd hh:mm:ss|
Private Const FORMAT_WHOLE_THOUSANDS = 	|###,###,###,###,##0|


Private Const ITEMNAME_BODY = 			|Body|
Private Const ITEMNAME_FORM = 			|Form|
Private Const ITEMNAME_HASERRORS = 		|hasErrors|
Private Const ITEMNAME_HASWARNINGS = 	|hasWarnings|
Private Const ITEMNAME_XMLCONTENT = 	|xmlContent|

Private Const LOGENTRY_BUFFER_MAX_COUNT = 	500 ' Maximum number of EnhancedLogEntry objects allowed in the buffer 
Private Const LOGENTRY_BUFFER_MAX_BYTES = 	5000 ' Maximum size (in bytes) of the EnhancedLogeEntry buffer 

Private Const LOGENTRY_TYPE_EXCEPTION = 	1
Private Const LOGENTRY_TYPE_WARNING = 		2
Private Const LOGENTRY_TYPE_EXTENDED = 		4
Private Const LOGENTRY_TYPE_METHODRESULT = 	8
Private Const LOGENTRY_TYPE_ACTION = 		16 

Private Const LOGTYPE_NOTES = 0
Private Const LOGTYPE_AGENT = 1
Private Const LOGTYPE_FILE = 2
Private Const LOGTYPE_MAIL = 4
Private Const LOGTYPE_EVENT = 8

Private Const MAX_RECOVER_ATTEMPTS = 3

Private Const PROFILENAME_ENHANCEDLOG = |enhLogOptionsProfile|

Private Const VIEWNAME_LOGS_BYLOGTIME = |lkp-LogsByLogTime|

Private Const VERSION = 		|1.96|
Private Const BUILD = 			|1.2152|
Private Const RELEASE_DATE = 	|22 DEC 2021|


%REM ***************************************************************************
 ************************************************************************************
	LSI_THREAD_xxxxx CONSTANTS  
	LSI constants declared here to avoid conflicts with 
	other libraries using lsconst.lss; which has its own 
	%INCLUDE "lsprcval.lss" command.
 ************************************************************************************
%END REM *********************************************************************
Private Const LIB_LSI_THREAD_LINE = 0
Private Const LIB_LSI_THREAD_PROC = 1
Private Const LIB_LSI_THREAD_MODULE = 2
Private Const LIB_LSI_THREAD_VERSION = 3
Private Const LIB_LSI_THREAD_LANGUAGE = 4
Private Const LIB_LSI_THREAD_COUNTRY = 5
Private Const LIB_LSI_THREAD_TICKS = 6
Private Const LIB_LSI_THREAD_TICKS_PER_SEC = 7
Private Const LIB_LSI_THREAD_PROCESS_ID = 8
Private Const LIB_LSI_THREAD_TASK_ID = 9
Private Const LIB_LSI_THREAD_CALLPROC = 10
Private Const LIB_LSI_THREAD_CALLMODULE = 11
Private Const LIB_LSI_THREAD_STACKINFO = 14



%REM ***************************************************************************
 ************************************************************************************
	ERROR CONSTANTS  
 ************************************************************************************
%END REM *********************************************************************
Private Const ERR_OPERATION_FAILED = 1000
Private Const MSG_OPERATION_FAILED = |The requested operation could not be completed.  |

Private Const ERR_DATABASE_NOTOPEN =  1063 
Private Const MSG_DATABASE_NOTOPEN = |Could not open the specified database.  |

Private Const ERR_MISSING_DATABASE =  1401
Private Const MSG_MISSING_DATABASE = |The specified database cannot be found.  |

Private Const ERR_MISSING_ITEM =  1426
Private Const MSG_MISSING_ITEM =  |The specified item is missing.  |

Private Const ERR_DOC_NOT_SAVED = 1257 
Private Const MSG_DOC_NOT_SAVED = |The document could not be saved.  |

Private Const ERR_FORMULA_INVALID = 1336
Private Const MSG_FORMULA_INVALID = |The Formula syntax is invalid.  |

Private Const ERR_INTERNAL = 1900
Private Const MSG_INTERNAL = |Internal Error in EnhancedLog object.  |

Private Const ERR_INTERNAL_MAXRECOVER = 1910
Private Const MSG_INTERNAL_MAXRECOVER = |Internal Error in EnhancedLog object.  Maximum allowed recovery attempts exceeded.  |

Private Const ERR_INTERNAL_NORECOVER = 1900
Private Const MSG_INTERNAL_NORECOVER = |Internal Error in EnhancedLog object.  ResumeOnLoggingFailure set to False.  No Recovery possible.  |

Private Const ERR_OBJECT_CREATE_FAILED = 1208
Private Const MSG_OBJECT_CREATE_FAILED = |Failed to create an Object.  |

Private Const ERR_METHOD_DEPRECATED = 1150
Private Const MSG_METHOD_DEPRECATED = |Method has been deprecated.  |

Private Const ERR_PARAMETER_BLANK = 1199
Private Const MSG_PARAMETER_BLANK = |A required parameter is blank or missing.  |

Private Const ERR_PARAMETER_INVALID = 1195
Private Const MSG_PARAMETER_INVALID = |A passed parameter is invalid.  |

Private Const ERR_LOGTARGET_NOTOPEN =  1070 
Private Const MSG_LOGTARGET_NOTOPEN = |The target log is not open.  |

Private Const ERR_DOCUMENT_NOT_FOUND = 1020
Private Const MSG_DOCUMENT_NOT_FOUND = |Could not find the specified document.  |

Private Const ERR_VIEW_NOT_FOUND = 1039
Private Const MSG_VIEW_NOT_FOUND = |Could not find the specified view.  |

Private Const ERR_PARENT_METHOD_NOT_ALLOWED = 1100
Private Const MSG_PARENT_METHOD_NOT_ALLOWED = |Method must be overridden in child class.  |



%REM ***************************************************************************
 ************************************************************************************
	PUBLIC UTILITY CONSTANTS  
 ************************************************************************************
%END REM *********************************************************************
Public Const FORMALIAS_EVENTS = |Events|
Public Const FORMNAME_ENHANCEDLOGCONFIG = |enhLogConfig|
Public Const FORMNAME_MEMO = |Memo|

Public Const ITEMNAME_ENHLOG_HTMLVIEWERSOURCE = |enhLog_HTMLviewerSource|
Public Const ITEMNAME_ENHLOG_PROFILEMETHODCOUNT = |enhLogProfileMethodCount|
Public Const ITEMNAME_ENHLOG_PURGE_AGE = |enhLogPurgeAge|
Public Const ITEMNAME_ENHLOG_TARGET_SERVER = |enhLogTargetServer|
Public Const ITEMNAME_ENHLOG_TARGET_FILEPATH = |enhLogTargetFilepath|
Public Const ITEMNAME_ENHLOG_YN_LOGACTIONS = |enhLogActions|
Public Const ITEMNAME_ENHLOG_YN_LOGENABLED = |enhLogEnabled|
Public Const ITEMNAME_ENHLOG_YN_LOGERRORS = |enhLogErrors|
Public Const ITEMNAME_ENHLOG_YN_LOGMETHODRESULTS = |enhLogMethodResults|
Public Const ITEMNAME_ENHLOG_YN_LOGSTACKEXCEPTIONS = |enhLogStackExceptions|
Public Const ITEMNAME_ENHLOG_YN_LOGWARNINGS = |enhLogWarnings|
Public Const ITEMNAME_ENHLOG_YN_LOCALECHO = |enhLogLocalEcho|
Public Const ITEMNAME_ENHLOG_YN_AUTOSAVE = |enhLogAutoSave|
Public Const ITEMNAME_ENHLOG_YN_OVERWRITE = |enhLogOverwriteFile|
Public Const ITEMNAME_ENHLOG_YN_RESUMEONFAIL = |enhLogResumeOnFail|
Public Const ITEMNAME_ENHLOG_YN_INCLUDEMETHODNAMES = |enhLogIncludeMethodNames|
Public Const ITEMNAME_ENHLOG_YN_PURGEENABLED = |enhLogEnableScheduledPurge|
Public Const ITEMNAME_ENHLOG_YN_PROFILINGENABLED = |enhLogEnableMethodProfiling|

Public Const LOG_DOC_MAX_SIZE = 500000

Public Const UNID_PREFIX = |UNID_|

Public Const VIEWNAME_DBCONFIG = |DbConfig|


%REM ***************************************************************************
 ************************************************************************************
	GLOBAL VARIABLES
 ************************************************************************************
%END REM *********************************************************************
Private lstrLogTypes List As String


%REM ***************************************************************************
 ************************************************************************************
	TYPE DEFINITION: ErrorInfo
 ************************************************************************************
%END REM *********************************************************************
Public Type ErrorInfo
	timestamp As String
	methodname As String
	callingmethod As String 
	linenumber As Integer
	code As Integer
	message As String
	extended As String
End Type  


%REM ***************************************************************************
 ************************************************************************************
	TYPE DEFINITION: ProfileMethod
 ************************************************************************************
%END REM *********************************************************************
Public Type ProfiledMethodElement 
	modulename As String 
	classname As String
	methodname As String 
	operation As String 
	elapsed As Double 
	ticks As Double
	calls As Long 
	recursions As Long 
	recursiondepth As Integer
	maxrecursiondepth As Integer
	isStarted As Boolean	
End Type 



%REM ***************************************************************************
 ************************************************************************************
	TYPE DEFINITION: LogEntry
 ************************************************************************************
%END REM *********************************************************************
Private Type LogEntry 
	logtime As Variant ' Variant of DataType 7 (Date/Time).
	
	message As String  
	extendedcontent As String  
	linkcomment As String  
	hotspottext As String
	errormethod As String 
		
	errormessage As String 
	errorline As Long
	errorcode As Integer 
	
	logentrytype As Integer
End Type 



%REM ***************************************************************************
 ************************************************************************************
	TYPE DEFINITION: StackTraceElement
 ************************************************************************************
%END REM *********************************************************************
Private Type StackTraceElement 
	module As String 
	linenumber As String 
	methodname As String 
End Type 



%REM ***************************************************************************
 ************************************************************************************
	Private Instance Objects 
 ************************************************************************************
%END REM *********************************************************************
Private singleton_ As Singleton
Private enhLog_ As EnhancedLog 

Private genhl_ProfiledMethods As ProfiledMethodList 
Private genhl_dbConfigDocCache List As NotesDocument
Private genhl_ProfileMethodStarts List As Integer       










%REM
	Class enhLogListCarrier
	Base Class for List Carriers 
%END REM
Private Class enhLogListCarrier
	
	Private Property Get CLASS_PREFIX As String 
		CLASS_PREFIX = LIB_PREFIX & |enhLogListCarrier.|
	End Property


	%REM
		Function getContent
		Description: Gets the content list for the object
		
		This method is designed to be overriden by child classes
	%END REM
	Function getContent() As Variant	
		Error ERR_PARENT_METHOD_NOT_ALLOWED, MSG_PARENT_METHOD_NOT_ALLOWED
	End Function

	
	%REM
		Function hasTag 
		Indicates if the specified tag represents an element in the internal List 
		
		@param tag$  ListTag for the element 
		
		@return Flag indicating if the tag represents an element in the internal list   
	%END REM
	Function hasTag(tag$) As Boolean 
		hasTag = IsList(me.getContent()) And IsElement(me.getContent()(tag$)) 
	End Function 
	
	
	%REM
		Property listTags
		Description: array of all ListTags
	%END REM
	Property Get listTags As Variant 
		listTags =  getListTags(me.getContent()) 
	End Property

	
	Property Get size As Long 
		size = getListSize(me.getContent()) 
	End Property
	
	Property Get hasContent As Boolean
		On Error GoTo ErrorTrap
		
		Dim result As Boolean 
		
		result = False 
		ForAll element In me.getContent()  
			result = True 
			Exit ForAll 
		End ForAll
		
	ExitPoint:
		hasContent = result
		Exit Property 
	ErrorTrap:
		On Error GoTo 0
		enhLogException CLASS_PREFIX, || 
		Resume ExitPoint 
	End Property
	
	
	
	
	%REM
		Function equals
		Description: Comares tags and values to another enhLogListCarrier 
		
		@param source enhLogListCarrier object to compare 
		@return True if all tags and values are identical 
	%END REM
	Function equals(source As enhLogListCarrier) As Boolean 
		On Error GoTo ErrorTrap 
		
		Dim tag$
		
		Dim result As Boolean 
		result = False 
		
		If (source Is Nothing) Then GoTo ExitPoint 
		If (me.CLASS_PREFIX <> source.CLASS_PREFIX) Then GoTo ExitPoint ' Class Prefix must match
		
		' check all tags and values from this object
		ForAll value In me.getContent() 
			tag$ = ListTag(value) 
			If Not source.hasTag(tag$) Then GoTo ExitPoint 
			If (value <> source.getContent()(tag$)) Then GoTo ExitPoint 
		End ForAll
		
		' check all tags and values from the passed in object
		ForAll value In source.getContent()
			tag$ = ListTag(value) 
			If Not me.hasTag(tag$) Then GoTo ExitPoint 
			If (value <> me.getContent()(tag$)) Then GoTo ExitPoint 
		End ForAll
		
		' no differences found 
		result = True
		
	ExitPoint:
		equals = result 
		Exit Function 
	ErrorTrap:
		On Error GoTo 0 
		enhLogException me.CLASS_PREFIX, |ListTag: | & tag$ 
		Resume ExitPoint 
	End Function
	
	
	%REM
		Function isEqual
		Description: Compares tags and values to another enhLogListCarrier 
		
		@param source 	enhLogListCarrier object to compare 
		
		@return 		Flag indicating all tags and values have equal values
	%END REM
	Function isEqual(source As enhLogListCarrier) As Boolean 	
		isEqual = me.equals(source) 
	End Function


End Class



%REM
	Class ProfiledMethod
	Carrier of information about a Profiled Method 
%END REM
Private Class ProfiledMethod 

	Private content As ProfiledMethodElement

	Private Property Get CLASS_PREFIX As String 
		CLASS_PREFIX = LIB_PREFIX & |ProfiledMethod.|
	End Property 

	%REM
		Property Get ModuleName
		Name of the Module containing the object 
	%END REM
	Property Get ModuleName As String 
		ModuleName = me.content.modulename 
	End Property

	%REM
		Property Get ClassName
		Name of the Class containing the object 
	%END REM
	Property Get ClassName As String 
		ClassName = me.content.classname 
	End Property

	%REM
		Property Get MethodName
		Name of the Method being profiled 
	%END REM
	Property Get MethodName As String 
		MethodName = me.content.methodname 
	End Property

	%REM
		Property Get Operation
		Operation (for a property, Get or Set) 
	%END REM
	Property Get Operation As String 
		Operation = me.content.operation
	End Property


	%REM
		Property Get Elapsed
		Elapsed time (in milliseconds) total for Object
	%END REM
	Property Get Elapsed As Long 
		Elapsed = me.content.elapsed 
	End Property

	%REM
		Property Get Ticks
		Operating system clock ticks (milliseconds) set for the object.  
	%END REM
	Property Get Ticks As Long 
		Ticks = me.content.ticks 
	End Property

	%REM
		Property Get Calls
		Number of times the method / operation being profiled has been called
	%END REM
	Property Get Calls As Long 
		Calls = me.content.calls 
	End Property

	%REM
		Property Get Recursions
		Number of recursive calls to the method / operation 
	%END REM
	Property Get Recursions As Long 
		Recursions = me.content.recursions 
	End Property

	%REM
		Property Get RecursionDepth
		Current recursion depth for the method / operation 
	%END REM
	Property Get RecursionDepth As Long 
		RecursionDepth = me.content.recursiondepth 
	End Property

	%REM
		Property Get MaxRecursionDepth
		Maximum recursion depth that has occurred for the method / operation 
	%END REM
	Property Get MaxRecursionDepth As Long 
		MaxRecursionDepth = me.content.maxrecursiondepth 
	End Property

	%REM
		Property Get isStarted
		Flag indicating if the operation / method is currently in a "started" state.
		Started being the method has begun operation, but not yet finished. 
	%END REM
	Property Get isStarted As Boolean 
		isStarted = me.content.isstarted  
	End Property



	%REM
		Property Set Operation
		Operation (for a property, Get or Set) 
	%END REM
	Property Set Operation As String 
		me.content.operation = Operation
	End Property

	%REM
		Property Set Elapsed
		Elapsed time (in milliseconds) total for Object
	%END REM
	Property Set Elapsed As Long 
		me.content.elapsed = Elapsed 
	End Property

	%REM
		Property Set Ticks
		Operating system clock ticks (milliseconds) set for the object.  
	%END REM
	Property Set Ticks As Long 
		me.content.ticks = Ticks 
	End Property


	%REM
		Property Set Calls
		Number of times the method / operation being profiled has been called
	%END REM
	Property Set Calls As Long 
		me.content.calls = Calls 
	End Property

	%REM
		Property Set Recursions
		Number of recursive calls to the method / operation 
	%END REM
	Property Set Recursions As Long 
		me.content.recursions = Recursions
	End Property

	%REM
		Property Set RecursionDepth
		Current recursion depth for the method / operation 
	%END REM
	Property Set RecursionDepth As Long 
		me.content.recursiondepth = RecursionDepth  
	End Property

	%REM
		Property Set MaxRecursionDepth
		Maximum recursion depth that has occurred for the method / operation 
	%END REM
	Property Set MaxRecursionDepth As Long 
		me.content.maxrecursiondepth = MaxRecursionDepth 
	End Property

	%REM
		Property Set isStarted
		Flag indicating if the operation / method is currently in a "started" state.
		Started being the method has begun operation, but not yet finished. 
	%END REM
	Property Set isStarted As Boolean 
		me.content.isstarted = isStarted  
	End Property


	%REM
		Constructor
	%END REM 
	Sub New(modulename$, classname$, methodname$, operation$, ticks&) 
		On Error GoTo ErrorTrap
		

		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
		Dim errmsg$
		Dim errcode%
		Dim errline%
		
		
		' BEGIN CODE 
		extendedinfo(|Module Name|) = modulename$
		extendedinfo(|Class Name|) = classname$
		extendedinfo(|Method Name|) = methodname$ 
		extendedinfo(|Operation|) = operation$ 
		extendedinfo(|Ticks|) = CStr(ticks&) 

		me.content.modulename = modulename$
		me.content.classname = classname$ 
		me.content.methodname = methodname$ 
		me.Operation = operation$ 
		me.Ticks = ticks& 
		


	ExitPoint: 
		If (0 <> errcode%) Then Error errcode%, errmsg$ & | at line | & CStr(errline%) & | in | & CLASS_PREFIX & |New() Constructor| 
		Exit Sub 
	ErrorTrap:
		On Error GoTo 0
		errcode% = Err() 
		errmsg$ = Error() 
		errline% = Erl()
		ForAll s In extendedinfo
			If isBlankString(msg$) Then 
				msg$ = ListTag(s) & |: | & s
			Else 
				msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
			End If
		End ForAll
		enhLogException CLASS_PREFIX, msg$
		Resume ExitPoint
	End Sub 


	

End Class



Private Class ProfiledMethodList As enhLogListCarrier
	Public content List As ProfiledMethod

	Public Sub New()
	End Sub

	Public Sub Delete()
		Erase me.content
	End Sub
	
	Private Property Get CLASS_PREFIX As String 
		CLASS_PREFIX = LIB_PREFIX & |ProfiledMethodList.|
	End Property


	%REM
		Function getContent
		Description: Gets the content list for the object
	%END REM
	Public Function getContent() As Variant 	
		getContent = me.content 	
	End Function
		
		
	Public Function getValue(tag$) As ProfiledMethod
		Dim result As ProfiledMethod 
		If IsElement(me.content(tag$)) Then Set result = me.content(tag$) Else Set result = Nothing 
		
		Set getValue = result  
	End Function 		

End Class 



Private Class NestedProfiledMethodList As enhLogListCarrier
	Public content List As ProfiledMethodList

	Public Sub New()
	End Sub

	Public Sub Delete()
		Erase me.content
	End Sub
	
	Private Property Get CLASS_PREFIX As String 
		CLASS_PREFIX = LIB_PREFIX & |NestedProfiledMethodList.|
	End Property

	%REM
		Function getContent
		Description: Gets the content list for the object
	%END REM
	Public Function getContent() As Variant 	
		getContent = me.content 	
	End Function

End Class  



%REM
	Class NotesLink
	Represents a NotesLink to a Database, View, or Document 
%END REM
Private Class NotesLink 
	Private notesurl_ As String 
	Private server_ As String 
	Private filepath_ As String 
	Private viewname_ As String
	Private replicaid_ As String 
	Private universalid_ As String 
	  
	
	Private Property Get CLASS_PREFIX As String 
		CLASS_PREFIX = LIB_PREFIX & |NotesLink.|
	End Property 

	%REM
		Constructor 
		@param source NotesDatabase, NotesView, or NotesDocument to be represented by this object. 
	%END REM 
	Sub New(linkTo As Variant) 
		On Error GoTo ErrorTrap
		
		Dim ndb As NotesDatabase
		Dim nvw As NotesView
		Dim ndoc As NotesDocument 
		
		Dim linkToType$ 

		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
		Dim errmsg$
		Dim errcode%
		Dim errline%
		
		
		' BEGIN CODE 
		
		If (linkTo Is Nothing) Then GoTo ExitPoint
		
		linkToType$ = TypeName(linkTo)
		extendedInfo(|LinkTo Type|) = linkToType$ 
		Select Case linkToType$
			Case |NOTESDATABASE|:
				Set ndb = linkTo
				
			Case |NOTESVIEW|:
				Set nvw = linkTo
				If Not IsEmpty(nvw.Aliases) Then
					ForAll viewalias In nvw.Aliases 
						Me.viewname_ = Trim$(viewalias)
						Exit ForAll 
					End ForAll 
				End If
				If isBlankString (Me.viewname_) Then me.viewname_ = nvw.Name 

				Set ndb = nvw.Parent 
				
			Case |NOTESDOCUMENT|:
				Set ndoc = linkTo 
				Me.universalid_ = ndoc.Universalid 
				
				Set ndb = ndoc.Parentdatabase 

			Case Else
				Error ERR_PARAMETER_INVALID, MSG_PARAMETER_INVALID & |Invalid LinkTo Type| 
		End Select 	

		Me.server_ = ndb.Server 
		Me.filepath_ = ndb.Filepath 
		Me.replicaid_ = ndb.Replicaid 
		
		Me.notesurl_ = |Notes:///|
		
		If Not isBlankString(ndb.Server) Then Me.notesurl_ = me.notesurl_ & ndb.Server & |!!|
		Me.notesurl_ = Me.notesurl_ & ndb.ReplicaID 
				
		Select Case linkToType$
			Case |NOTESVIEW|:
				Me.notesurl_ = Me.notesurl_ & |/| & Me.viewname_  
				
			Case |NOTESDOCUMENT|:
				Me.notesurl_ = Me.notesurl_ & |/0/| & Me.universalid_   
		End Select 	
		 
		%REM TODO 
		Object should have Property Get Text (or similar) in place of NotesURL 
				
				Document Link
					Enhanced Log - Demo - Log A Lot of Stuff on (Local Client:c:\Notes\Data\enhLog.nsf) at 12/21/2021 10:20:21 AM EST by Devin Olson/azlighthouse
					<NDL>
					<REPLICA 85258765:005D91D6>
					<VIEW OFDF668089:A058A324-ON862577FA:00762127>
					<NOTE OFDE16A107:607D890E-ON852587B2:0054465E>
					<HINT>   /</HINT>
					<REM>Database 'Enhanced Log', View 'Logs\by Log Time', Document 'Demo - Log A Lot of Stuff on (Local Client:c:\Notes\Data\enhLog.nsf) at 12/21/2021 10:20:21 AM EST by Devin Olson/azlighthouse'</REM>
					</NDL>
				
				
				View Link 
					Enhanced Log - Logs\by Log Time
					<NDL>
					<REPLICA 85258765:005D91D6>
					<VIEW OFDF668089:A058A324-ON862577FA:00762127>
					<HINT>   /</HINT>
					<REM>Enhanced Log</REM>
					</NDL>
				
				
				Database Link 
					Enhanced Log    
					<NDL>
					<REPLICA 85258765:005D91D6>
					<HINT>   /</HINT>
					<REM>Enhanced Log</REM>
					</NDL>
					
		%END REM		 
		 
		 
		

	ExitPoint: 
		If (0 <> errcode%) Then Error errcode%, errmsg$ & | at line | & CStr(errline%) & | in | & CLASS_PREFIX & |New() Constructor| 
		Exit Sub 
	ErrorTrap:
		On Error GoTo 0
		errcode% = Err() 
		errmsg$ = Error() 
		errline% = Erl()
		ForAll s In extendedinfo
			If isBlankString(msg$) Then 
				msg$ = ListTag(s) & |: | & s
			Else 
				msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
			End If
		End ForAll
		enhLogException CLASS_PREFIX, msg$
		Resume ExitPoint
	End Sub 

	%REM
 		Property Get NotesURL
 		@return NotesURL for the entry 
	%END REM
	Property Get NotesURL As String 
		NotesURL = me.notesurl_
	End Property

	%REM
 		Property Get Server
 		@return Server for the entry 
	%END REM
	Property Get Server As String 
		Server = me.server_
	End Property

	%REM
 		Property Get Filepath
 		@return Filepath for the entry 
	%END REM
	Property Get Filepath As String 
		Filepath = me.filepath_
	End Property

	%REM
 		Property Get ReplicaID
 		@return ReplicaID for the entry 
	%END REM
	Property Get ReplicaID As String 
		ReplicaID = me.replicaid_
	End Property

	%REM
 		Property Get Viewname
 		@return Viewname for the entry 
	%END REM
	Property Get Viewname As String 
		Viewname = me.viewname_
	End Property

	%REM
 		Property Get UniversalID
 		@return UniversalID for the entry 
	%END REM
	Property Get UniversalID As String 
		UniversalID = me.universalid_
	End Property
	
	
	%REM
		Property Get size
		Size (in bytes) of the object 
		
		@return number of bytes used by the object. 
	%END REM
	Property Get size As Long 
		On Error GoTo ErrorTrap
		
		Dim result As Long 
		
		' BEGIN CODE
		With Me 
			result = LenB(.notesurl_) _
				+ LenB(.server) _ 
				+ LenB(.filepath_) _ 
				+ LenB(.viewname_) _ 
				+ LenB(.replicaid_) _ 
				+ LenB(.universalid_) 
		End With
		
		
	ExitPoint: 
		size = result
		Exit Property 
	ErrorTrap:
		On Error GoTo 0
		enhLogException CLASS_PREFIX, ||
		Resume ExitPoint
	End Property


	%REM
		Property Get NotesObject
		Notes Object (NotesDatabase, NotesView, or NotesDocument) represented by this NotesLink object. 
		
		@return Notes Object for the link.
	%END REM
	Property Get NotesObject As Variant 
		On Error GoTo ErrorTrap
	
		Dim ndb As NotesDatabase 
		Dim nvw As NotesView 
		Dim ndoc As NotesDocument 
	
	
		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
	
		Dim result As Variant 
	
	
		' BEGIN CODE
		Set result = Nothing 
		extendedinfo(|Filepath|) = me.Filepath 
		extendedinfo(|NotesURL|) = me.NotesURL 
		extendedinfo(|ReplicaID|) = me.ReplicaID 
		extendedinfo(|Server|) = me.Server 
		extendedinfo(|UniversalID|) = me.UniversalID 
		extendedinfo(|ViewName|) = me.ViewName 
		
		Set ndb = getOpenDatabase(me.Server, me.Filepath) 		
		If isBlankString(me.UniversalID) Then 
			' Not a NotesDocument 
			If isBlankString(me.Viewname) Then 
				' Not a view, return the Database 
				Set result = ndb 
			Else 
				' return a View 
				Set result = ndb.GetView(Viewname) 
				If (result Is Nothing) Then Error ERR_VIEW_NOT_FOUND, MSG_VIEW_NOT_FOUND 
			End If
		Else 
 			' return a Document 
 			Set result = ndb.getDocumentByUNID(me.UniversalID) 
			If (result Is Nothing) Then Error ERR_DOCUMENT_NOT_FOUND, MSG_DOCUMENT_NOT_FOUND 
		End If	
		
			
	ExitPoint: 
		Set NotesObject = result
		Exit Property 
	ErrorTrap:
		On Error GoTo 0
		ForAll s In extendedinfo
			If isBlankString(msg$) Then 
				msg$ = ListTag(s) & |: | & s
			Else 
				msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
			End If
		End ForAll
		enhLogException CLASS_PREFIX, msg$
		Resume ExitPoint
	End Property

End Class



%REM
	Class EnhancedLogStackTrace
	Represents a Stack Trace
%END REM
Private Class EnhancedLogStackTrace 
	Public Content() As StackTraceElement

	Private module_ As String
	Private count_ As Integer  
	
	

	
	Private Property Get CLASS_PREFIX As String 
		CLASS_PREFIX = LIB_PREFIX & |StackTrace.|
	End Property 

	%REM
		Constructor
	%END REM 
	Sub New() 
		On Error GoTo ErrorTrap
		
		Dim ste As StackTraceElement 
		
		Dim stackinfo As Variant 
		Dim stackelement As Variant
		
		Dim steModule$
		Dim steMethodname$
		Dim steLinenumber$
		
		Dim idx%
		
		Dim isStackStarted As Boolean 

		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
		Dim errmsg$
		Dim errcode%
		Dim errline%
		
		
		' BEGIN CODE 
		ReDim Preserve me.Content(me.count_) As StackTraceElement 
		me.module_ = GetThreadInfo(LIB_LSI_THREAD_MODULE)
		stackinfo =  Split(LSI_Info(LIB_LSI_THREAD_STACKINFO), Chr(10))
		
		ForAll element In stackinfo
			idx% = UBound(me.Content) 
			stackelement = Split(element, |,|) 
			steModule$ = Trim$(stackelement(0))
			If (UBound(stackelement) >= 1) Then steMethodname$ = Trim$(stackelement(1)) Else steMethodname$ = ||
			If (UBound(stackelement) >= 2) Then steLinenumber$ = Trim$(CStr(stackelement(2))) Else steLinenumber$ = ||
			
			If Not isBlankString(steMethodname$) Then 
				If Not isStackStarted Then 
					Select Case steMethodname$
						Case |LOGSTACKTRACE|, |LOGEXCEPTION|, |LOGEXCEPTIONWITHLINK|, |ENHLOGEXCEPTION|, |ENHLOGSTACKTRACE|
							isStackStarted = (Trim$(stackelement(0)) <> me.module_)
						Case Else
							isStackStarted = True
					End Select 	
				End If

				If isStackStarted Then
					ste.module = steModule$
					ste.methodname = steMethodname$
					ste.linenumber = steLinenumber$ 
					ReDim Preserve me.Content(me.count_) As StackTraceElement 
					me.Content(me.count_) = ste 
					me.count_ = me.count_ + 1
				End If 
			End If
		End ForAll 


	ExitPoint: 
		If (0 <> errcode%) Then Error errcode%, errmsg$ & | at line | & CStr(errline%) & | in | & CLASS_PREFIX & |New() Constructor| 
		Exit Sub 
	ErrorTrap:
		On Error GoTo 0
		errcode% = Err() 
		errmsg$ = Error() 
		errline% = Erl()
		ForAll s In extendedinfo
			If isBlankString(msg$) Then 
				msg$ = ListTag(s) & |: | & s
			Else 
				msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
			End If
		End ForAll
		enhLogException CLASS_PREFIX, msg$
		Resume ExitPoint
	End Sub 


	%REM
 		Property Get Module
 		@return Module from which the Stack Trace was triggered
	%END REM
	Property Get Module As String  
		Module = me.module_
	End Property


	%REM
		Property Get size
		Size (in bytes) of the object 
		
		@return number of bytes used by the object. 
	%END REM
	Property Get size As Long 
		On Error GoTo ErrorTrap
		
		Dim result As Long 
		
		' BEGIN CODE
		result = LenB(me.module_) 
		ForAll ste In me.Content 
			result = result + LenB(ste.linenumber) + LenB(ste.methodname) + LenB(ste.module) 
		End ForAll
		
	ExitPoint: 
		size = result
		Exit Property 
	ErrorTrap:
		On Error GoTo 0
		enhLogException CLASS_PREFIX, ||
		Resume ExitPoint
	End Property

End Class   



%REM
	Class EnhancedLogEntry
	Represents an individual Log Entry element 
%END REM
Private Class EnhancedLogEntry 

	Private content_ As LogEntry
	Private link_ As NotesLink
	Private stacktrace_ As EnhancedLogStackTrace 

	Private Property Get CLASS_PREFIX As String 
		CLASS_PREFIX = LIB_PREFIX & |EnhancedLogEntry.|
	End Property 

	%REM
		Constructor
		
		@param logtype% LOGENTRY_TYPE_XXX (Exception, Warning, etc.)
		@param message$ information to be written to the log. 
		@param extendedcontent$ Extended Content to be written. 
		@param linkTo Object for which to include a Link in the log
		@param linkcomment$ Comment for the link
		@param hotspottext$ HotSpotText for the link 
		@param errorcode% Error code (for errors) 
		@param errormessage$ Error message (for errors)
		@param errorline& Line Number where the error occurred. 
		@param errormethod$ Name of the method within wich the error occurred.
		@param st StackTrace information for the entry 
		
	%END REM 
	Sub New(logtype%, ByVal message$, ByVal extendedcontent$, linkTo As Variant, ByVal linkcomment$, ByVal hotspottext$, errorcode%, errormessage$, errorline&, errormethod$, st As EnhancedLogStackTrace) 

		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
		Dim errmsg$
		Dim errcode%
		Dim errline%
		
		On Error GoTo ErrorTrap
		
		
		' BEGIN CODE 
		me.content_.logtime = Now 
		me.content_.logentrytype = logtype% 
		me.content_.message = message$ 
		me.content_.extendedcontent = extendedcontent$
		me.content_.errorcode = errorcode%
		me.content_.errormessage = errormessage$
		me.content_.errorline = errorline&
		me.content_.errormethod = errormethod$ 
		me.content_.linkcomment = linkcomment$ 
		
		extendedinfo(|Log Entry Type|) = CStr(logtype%) 
		If Not isBlankString(message$) Then extendedinfo(|Message|) = message$
		If Not isBlankString(extendedcontent$) Then extendedinfo(|Extended Content|) = extendedcontent$ 
		If Not isBlankString(linkcomment$) Then extendedinfo(|Link Comment|) = linkcomment$
		If Not isBlankString(hotspottext$) Then extendedinfo(|Hot Spot Text|) = hotspottext$
		Set me.stacktrace_ = st 
		
		If (linkTo Is Nothing) Then GoTo ExitPoint
		
		Set me.link_ = New NotesLink(linkTo) 
		
	ExitPoint: 
		If (0 <> errcode%) Then Error errcode%, errmsg$ & | at line | & CStr(errline%) & | in | & CLASS_PREFIX & |New() Constructor| 
		Exit Sub 
	ErrorTrap:
		On Error GoTo 0
		errcode% = Err() 
		errmsg$ = Error() 
		errline% = Erl()
		ForAll s In extendedinfo
			If isBlankString(msg$) Then 
				msg$ = ListTag(s) & |: | & s
			Else 
				msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
			End If
		End ForAll
		enhLogException CLASS_PREFIX, msg$
		Resume ExitPoint
	End Sub 


	%REM
 		Property Get LogTime
 		@return Date/Time of the log entry, Variant of DataType 7 (Date/Time).
	%END REM
	Property Get LogTime As Variant ' Variant of DataType 7 (Date/Time).
		LogTime = me.content_.logtime
	End Property

	%REM
 		Property Get LinkTo
 		@return NotesLink for which to include a Link in the log.
	%END REM
	Property Get LinkTo As NotesLink 
		Set LinkTo = me.link_ 
	End Property

	%REM
 		Property Get LogEntryType
	%END REM
	Property Get LogEntryType As Integer 
		LogEntryType = me.content_.logentrytype
	End Property

	%REM
 		Property Get TimeStamp	
 		@return text representation of the logtime 
	%END REM
	Property Get TimeStamp As String 
		TimeStamp = Format$(me.content_.logtime, FORMAT_TIMESTAMP)
	End Property


	%REM
 		Property Get Message
 		@return Message for the entry 
	%END REM
	Property Get Message As String 
		Message = me.content_.message
	End Property

	%REM
 		Property Get ExtendedContent
 		@return ExtendedContent for the entry 
	%END REM
	Property Get ExtendedContent As String 
		ExtendedContent = me.content_.extendedcontent
	End Property

	%REM
 		Property Get LinkComment
 		@return LinkComment for the entry 
	%END REM
	Property Get LinkComment As String 
		LinkComment = me.content_.linkcomment
	End Property

	%REM
 		Property Get HotSpotText
 		@return HotSpotText for the entry 
	%END REM
	Property Get HotSpotText As String 
		HotSpotText = me.content_.hotspottext
	End Property

	%REM
 		Property Get ErrorMessage
 		@return ErrorMessage for the entry 
	%END REM
	Property Get ErrorMessage As String 
		ErrorMessage = me.content_.errormessage
	End Property

	%REM
 		Property Get ErrorMethod
 		@return ErrorMethod for the entry 
	%END REM
	Property Get ErrorMethod As String 
		ErrorMethod = me.content_.errormethod
	End Property

	%REM
 		Property Get ErrorLine
 		@return ErrorLine for the entry 
	%END REM
	Property Get ErrorLine As Long 
		ErrorLine = me.content_.errorline
	End Property	

	%REM
 		Property Get ErrorCode
 		@return ErrorCode for the entry 
	%END REM
	Property Get ErrorCode As Integer 
		ErrorCode = me.content_.errorcode
	End Property

	%REM
 		Property Get hasLink
 		@return Flag indicating if the object has a link
	%END REM
	Property Get hasLink As Boolean 
		hasLink = Not (me.link_ Is Nothing)  
	End Property


	%REM
 		Property Get StackTrace
 		@return StackTrace for the entry 
	%END REM
	Property Get StackTrace As EnhancedLogStackTrace 
		Set StackTrace = me.stacktrace_ 
	End Property



	%REM
		Property Get size
		Size (in bytes) of the object 
		
		@return number of bytes used by the object. 
	%END REM
	Property Get size As Long 
		On Error GoTo ErrorTrap
	
		Dim result As Long 
	
		' BEGIN CODE
		result = LenB(me.TimeStamp) _
			+ LenB(me.content_.message) _ 
			+ LenB(me.content_.extendedcontent) _ 
			+ LenB(me.content_.linkcomment) _ 
			+ LenB(me.content_.hotspottext) _ 
			+ Len(me.content_.logentrytype) _ 
			+ Len(me.content_.errorcode) _ 
			+ LenB(me.content_.errormessage) _ 
			+ Len(me.content_.errorline) _ 
			+ LenB(me.content_.errormethod) 
		
		If me.hasLink Then result = result + me.link_.size 
		If Not (me.stacktrace_ Is Nothing) Then result = result + me.stacktrace_.size 
		
	ExitPoint: 
		size = result
		Exit Property 
	ErrorTrap:
		On Error GoTo 0
		enhLogException CLASS_PREFIX, ||
		Resume ExitPoint
	End Property




End Class   



%REM
	Class EnhancedLogEntryBuffer
	Container for EnhancedLogEntry elements.
%END REM
Private Class EnhancedLogEntryBuffer
	Private content(LOGENTRY_BUFFER_MAX_COUNT) As EnhancedLogEntry
	Private count_ As Integer 
	Private index_ As Integer 
	
	Public Sub New()
	End Sub

	Public Sub Delete()
	End Sub
	
	Private Property Get CLASS_PREFIX As String 
		CLASS_PREFIX = LIB_PREFIX & |EnhancedLogEntryBuffer.|
	End Property
	
	
	
	%REM
		Sub Clear
		Clears the Buffer 
	%END REM
	Public Sub Clear() 
		On Error GoTo ErrorTrap
		
		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
		
		Dim idx%
		
		' BEGIN CODE 
		Erase me.content
		
		For idx% = 0 To LOGENTRY_BUFFER_MAX_COUNT 
			extendedinfo(|Index|) = CStr(idx%)
			Set me.content(idx%) = Nothing
		Next

		me.count_ = 0
		me.index_ = 0
		
	ExitPoint: 
		Exit Sub 
	ErrorTrap:
		On Error GoTo 0
		ForAll s In extendedinfo
			If isBlankString(msg$) Then 
				msg$ = ListTag(s) & |: | & s
			Else 
				msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
			End If
		End ForAll
		enhLogException CLASS_PREFIX, msg$
		Resume ExitPoint		
	End Sub


	%REM
		Property Get isFull
		Indicates if the buffer is full.
		
		A full buffer either has LOGENTRY_BUFFER_MAX_COUNT (or more) entries, 
		or has a size greater or equal to LOGENTRY_BUFFER_MAX_BYTES
		
		@return Flag indicating if the buffer is full. 
	%END REM
	Property Get isFull As Boolean 
		On Error GoTo ErrorTrap
	
		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
		
		
		Dim result As Boolean
		
		
		' BEGIN CODE
		result = (me.count => LOGENTRY_BUFFER_MAX_COUNT)
		If Not result Then result = (me.size => LOGENTRY_BUFFER_MAX_BYTES) 
		
		ExitPoint: 
			isFull = result
			Exit Property 
		ErrorTrap:
			On Error GoTo 0
			ForAll s In extendedinfo
				If isBlankString(msg$) Then 
					msg$ = ListTag(s) & |: | & s
				Else 
					msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
				End If
			End ForAll
			enhLogException CLASS_PREFIX, msg$
			Resume ExitPoint
	End Property


	%REM
 		Property Get count
 		 
 		@return Number of entries in the buffer 
	%END REM
	Property Get count As Integer 
		count = me.count_ 
	End Property

	%REM
		Property Get NextEntry
		Gets the next entry in the buffer 
		
		@return Next EnhancedLogEntry  
	%END REM
	Property Get NextEntry As EnhancedLogEntry 	
		On Error GoTo ErrorTrap
	
		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
	
	
		Dim result As EnhancedLogEntry
	
		' BEGIN CODE
		extendedinfo(|Index|) = me.index_ 
		Set result = me.content(me.index_) 
		If (me.index_ <= me.count_) Then me.index_ = me.index_ + 1 
	
	ExitPoint: 
		Set NextEntry = result
		Exit Property 
	ErrorTrap:
		On Error GoTo 0
		ForAll s In extendedinfo
			If isBlankString(msg$) Then 
				msg$ = ListTag(s) & |: | & s
			Else 
				msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
			End If
		End ForAll
		enhLogException CLASS_PREFIX, msg$
		Resume ExitPoint
	End Property


	%REM
		Property Get FirstEntry
		Gets the first entry in the buffer 
	%END REM
	Property Get FirstEntry As EnhancedLogEntry 
		On Error GoTo ErrorTrap
	
		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
	
	
		Dim result As EnhancedLogEntry
	
		' BEGIN CODE
		me.index_ = 0 
		Set result = me.NextEntry 
	
	ExitPoint: 
		Set FirstEntry = result
		Exit Property 
	ErrorTrap:
		On Error GoTo 0
		ForAll s In extendedinfo
			If isBlankString(msg$) Then 
				msg$ = ListTag(s) & |: | & s
			Else 
				msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
			End If
		End ForAll
		enhLogException CLASS_PREFIX, msg$
		Resume ExitPoint
	End Property


	%REM
		Property Get LastEntry
		Gets the last entry in the buffer 
	%END REM
	Property Get LastEntry As EnhancedLogEntry 
		On Error GoTo ErrorTrap
		
		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
		
		
		Dim result As EnhancedLogEntry
		
		' BEGIN CODE
		If (me.count_ > 0) Then 
			me.index_ = me.count_ -1
		Else 
			me.index_ = 0
		End If
		Set result = me.NextEntry 
		
	ExitPoint: 
		Set LastEntry = result
		Exit Property 
	ErrorTrap:
		On Error GoTo 0
		ForAll s In extendedinfo
			If isBlankString(msg$) Then 
				msg$ = ListTag(s) & |: | & s
			Else 
				msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
			End If
		End ForAll
		enhLogException CLASS_PREFIX, msg$
		Resume ExitPoint
	End Property  
	
	
	%REM
		Sub addEntry
		Adds an entry to the buffer 
	%END REM
	Sub addEntry(source As EnhancedLogEntry) 
		On Error GoTo ErrorTrap
		
		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
		
		
		' BEGIN CODE  
		If me.isFull Then Error ERR_INTERNAL, MSG_INTERNAL & |Buffer is full.  Additional entries cannot be added.  |
		Set me.content(me.count_) = source
		me.count_ = me.count_ + 1 
		
		
	ExitPoint: 
		Exit Sub 
	ErrorTrap:
		On Error GoTo 0
		ForAll s In extendedinfo
			If isBlankString(msg$) Then 
				msg$ = ListTag(s) & |: | & s
			Else 
				msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
			End If
		End ForAll
		enhLogException CLASS_PREFIX, msg$
		Resume ExitPoint
	End Sub

	%REM
		Property Get size
		Size (in bytes) of the object 
		
		@return number of bytes used by the object. 
	%END REM
	Property Get size As Long 
		On Error GoTo ErrorTrap
		
		Dim entry As EnhancedLogEntry 
		Dim result As Long 

		Dim idx% 

		' BEGIN CODE
		For idx% = 0 To Me.count
			Set entry = me.content(idx%) 
			If Not (entry Is Nothing) Then 
				result = result + entry.size 
			End If 
		Next
		
	ExitPoint: 
		size = result
		Exit Property 
	ErrorTrap:
		On Error GoTo 0
		enhLogException CLASS_PREFIX, ||
		Resume ExitPoint
	End Property

	%REM
		Function hasLogEntryCount
		Indicates if EnhancedLogEntries for the specified Enhanced Log Entry Type are contained in the buffer 
		
		@param logtype% LOGENTRY_TYPE_XXX (Exception, Warning, etc.)
		
		@return Flat indicating if EnhancedLogEntry objects which have Log Entry Type equal to logtype% exist in the buffer  
	%END REM
	Function hasLogEntryCount(logtype%) As Integer  
		On Error GoTo ErrorTrap
		
		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
		
		Dim i% 
		Dim ele As EnhancedLogEntry 
		
		Dim result%
		
		' BEGIN CODE
		If me.count_ > 0 Then 
			For i% = 0 To me.count_ 
				Set ele = me.content(i%) 
				If (ele Is Nothing) Then GoTo ExitPoint
				If (ele.LogEntryType And logtype%) Then  ' logical bitwise comparison
					result = True 
					GoTo ExitPoint  
				End If 
			Next
		End If 
		
	ExitPoint: 
		hasLogEntryCount = result
		Exit Function 
	ErrorTrap:
		On Error GoTo 0
		ForAll s In extendedinfo
			If isBlankString(msg$) Then 
				msg$ = ListTag(s) & |: | & s
			Else 
				msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
			End If
		End ForAll
		enhLogException CLASS_PREFIX, msg$
		Resume ExitPoint
	End Function

	%REM
 		Property Get hasACTION
 		@return Flag indicating if EnhancedLogEntry objects with LogEntryType of LOGENTRY_TYPE_ACTION, LOGENTRY_TYPE_METHODRESULT, or LOGENTRY_TYPE_EXTENDED exist in the buffer
	%END REM
	Property Get hasACTION As Boolean 
		hasACTION = me.hasLogEntryCount(LOGENTRY_TYPE_ACTION + LOGENTRY_TYPE_METHODRESULT + LOGENTRY_TYPE_EXTENDED)
	End Property

	%REM
 		Property Get hasMETHODRESULT
 		@return Flag indicating if EnhancedLogEntry objects with LogEntryType of LOGENTRY_TYPE_METHODRESULT exist in the buffer
 	%END REM
	Property Get hasMETHODRESULT As Boolean 
		hasMETHODRESULT = me.hasLogEntryCount(LOGENTRY_TYPE_METHODRESULT)
	End Property

	%REM
 		Property Get hasEXTENDED
  		@return Flag indicating if EnhancedLogEntry objects with LogEntryType of LOGENTRY_TYPE_EXTENDED exist in the buffer
 	%END REM
	Property Get hasEXTENDED As Boolean 
		hasEXTENDED = me.hasLogEntryCount(LOGENTRY_TYPE_EXTENDED)
	End Property

	%REM
 		Property Get hasWARNING
  		@return Flag indicating if EnhancedLogEntry objects with LogEntryType of LOGENTRY_TYPE_WARNING exist in the buffer
 	%END REM
	Property Get hasWARNING As Boolean 
		hasWARNING = me.hasLogEntryCount(LOGENTRY_TYPE_WARNING)
	End Property

	%REM
 		Property Get hasEXCEPTION
 		@return Flag indicating if EnhancedLogEntry objects with LogEntryType of LOGENTRY_TYPE_EXCEPTION exist in the buffer
 	%END REM
	Property Get hasEXCEPTION As Boolean 
		hasEXCEPTION = me.hasLogEntryCount(LOGENTRY_TYPE_EXCEPTION)
	End Property


	%REM
		Function getEntryCount
		Count of EnhancedLogEntries for the specified Enhanced Log Entry Type 
		
		@param logtype% LOGENTRY_TYPE_XXX (Exception, Warning, etc.)
		
		@return Number of EnhancedLogEntry objects which have Log Entry Type equal to logtype% 
	%END REM
	Function getLogEntryCount(logtype%) As Integer  
		On Error GoTo ErrorTrap
		
		' exception variables
		Dim extendedinfo List As String 
		Dim msg$
		
		Dim i% 
		Dim ele As EnhancedLogEntry 
		
		Dim result%
		
		' BEGIN CODE
		If me.count_ > 0 Then 
			For i% = 0 To me.count_ 
				Set ele = me.content(i%) 
				If (ele Is Nothing) Then GoTo ExitPoint
				If (ele.LogEntryType And logtype%) Then result% = result% + 1 ' logical bitwise comparison
			Next
		End If 
		
	ExitPoint: 
		getLogEntryCount = result
		Exit Function 
	ErrorTrap:
		On Error GoTo 0
		ForAll s In extendedinfo
			If isBlankString(msg$) Then 
				msg$ = ListTag(s) & |: | & s
			Else 
				msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
			End If
		End ForAll
		enhLogException CLASS_PREFIX, msg$
		Resume ExitPoint
	End Function

	%REM
 		Property Get countACTION
 		@return count of EnhancedLogEntry objects with LogEntryType of LOGENTRY_TYPE_ACTION, LOGENTRY_TYPE_METHODRESULT, or LOGENTRY_TYPE_EXTENDED
	%END REM
	Property Get countACTION As Integer 
		countACTION = me.getLogEntryCount(LOGENTRY_TYPE_ACTION + LOGENTRY_TYPE_METHODRESULT + LOGENTRY_TYPE_EXTENDED)
	End Property

	%REM
 		Property Get countMETHODRESULT
 		@return count of EnhancedLogEntry objects with LogEntryType = LOGENTRY_TYPE_METHODRESULT
	%END REM
	Property Get countMETHODRESULT As Integer 
		countMETHODRESULT = me.getLogEntryCount(LOGENTRY_TYPE_METHODRESULT)
	End Property

	%REM
 		Property Get countEXTENDED
 		@return count of EnhancedLogEntry objects with LogEntryType = LOGENTRY_TYPE_EXTENDED
	%END REM
	Property Get countEXTENDED As Integer 
		countEXTENDED = me.getLogEntryCount(LOGENTRY_TYPE_EXTENDED)
	End Property

	%REM
 		Property Get countWARNING
 		@return count of EnhancedLogEntry objects with LogEntryType = LOGENTRY_TYPE_WARNING
	%END REM
	Property Get countWARNING As Integer 
		countWARNING = me.getLogEntryCount(LOGENTRY_TYPE_WARNING)
	End Property

	%REM
 		Property Get countEXCEPTION
 		@return count of EnhancedLogEntry objects with LogEntryType = LOGENTRY_TYPE_EXCEPTION
	%END REM
	Property Get countEXCEPTION As Integer 
		countEXCEPTION = me.getLogEntryCount(LOGENTRY_TYPE_EXCEPTION)
	End Property


End Class   



Private Class Singleton 	' Declaring as Private allows for Singleton functionality.
	Private targetDb_ As NotesDatabase
	Private ndoc_ As NotesDocument
	Private nrti_ As NotesRichTextItem
	Private xmlnrti_ As NotesRichTextItem 
	Private nlog_ As NotesLog
	
	Private nrtstyleTimestampNormal As NotesRichTextStyle
	Private nrtstyleTimestampError As NotesRichTextStyle
	Private nrtstyleTimestampExtended As NotesRichTextStyle
	Private nrtstyleTimestampWarning As NotesRichTextStyle
	Private nrtstyleExtendedContent As NotesRichTextStyle
	Private nrtstyleAction As NotesRichTextStyle
	Private nrtstyleMethodResult As NotesRichTextStyle
	Private nrtstyleError As NotesRichTextStyle
	Private nrtstyleErrorExtended As NotesRichTextStyle
	Private nrtstyleWarning As NotesRichTextStyle
	Private nrtstyleTableHeader As NotesRichTextStyle
	Private nrtstyleTableHeaderLabel As NotesRichTextStyle
	Private nrtstyleXMLcontent As NotesRichTextStyle
	
	Private nrtparastyle As NotesRichTextParagraphStyle
	
	Private nagt As NotesAgent
	Private nnamUser As NotesName
	Private ndtStartTime As NotesDateTime
	
	Private cachedErrors List As ErrorInfo  
	Private internalErrorStack() As ErrorInfo 
	
	Private buffer As EnhancedLogEntryBuffer

	Private myLinkTo As Variant 
	
	Private userRoles As Variant
	Private varSendTo As Variant
	
	Private dbServer As String
	Private agentOwner As String
	Private abbrevUserName As String
	Private dbTitle As String
	Private dbFilepath As String
	Private dbRepID As String
	
	Private mySubject As String
	Private myLinkComment As String 
	Private myLinkHotspotText As String 
	Private myNotesVersion As String 
	
	Private progName As String 
	Private starttimestamp_ As String
	Private targetfilepath_ As String 
	
	Private internalErrorCount As Integer 
	
	
	Private countCachedErrors As Long
	
	
	Private targetfilehandle_ As Integer 
	
	
	Private saverecursions_ As Integer
	Private writecount_ As Integer
	
	Private acl As Integer
	Private logType As Byte
	Private countInternalErrors As Byte
	
	
	Private doLocalEcho As Boolean
	Private doLogActions As Boolean
	Private doLogErrors As Boolean	
	Private doLogMethodResults As Boolean
	Private doLogStackExceptions As Boolean
	Private doLogWarnings As Boolean	
	Private doActionsIncludeMethodNames As Boolean
	Private doAutoSave As Boolean
	Private doLogOutputToNotesLog As Boolean 
	Private doOverwriteFile As Boolean
	Private doResumeOnLoggingFailure As Boolean
	Private hasLogConfigDoc As Boolean
	Private isLogEnabled As Boolean
	Private isLogTypeChanged As Boolean
	Private isSpanningLogDocs As Boolean
	Private isInstantiating As Boolean
	Private exists As Boolean
	Private myHasLinkInfo As Boolean  
	Private hasLoggedAction As Boolean 
	Private hasLoggedException As Boolean 
	Private hasLoggedWarning As Boolean 
	
	
	Private Property Get CLASS_PREFIX As String 
		CLASS_PREFIX = LIB_PREFIX & |Singleton.|
	End Property	
	
	Public Sub New (ByVal programName$)
		Dim nnam As NotesName
		Dim temp As String 
		Dim isAgent As Boolean
		
		Call InstantiateLoggingSession()
		Call Me.instantiate()
		
		TrimString programName$
		If (Len(programName$) > 0) Then Me.progName$ = programName$



		temp$ = Trim$(getCurrentDb().Server) 
		If (Len(temp$) > 0) Then 
			Set nnam = New NotesName(getCurrentDb().Server)
			Me.dbServer = nnam.Abbreviated
		Else
			Me.dbServer = |Local Client|
		End If 

		Me.dbTitle$ = getCurrentDb().Title
		Me.dbFilepath$ = getCurrentDb().FilePath
		Me.dbRepID$ = CStr(getCurrentDb().ReplicaID)
		
		Set nnam = Me.UserName 	' called to instantiate the UserName
		Me.logType = LOGTYPE_NOTES
		
		Me.userRoles = Evaluate(|@UserRoles|)
		Me.acl = getCurrentDb().CurrentAccessLevel
		Call Me.ClearCachedError()
	End Sub 
	
	
	
	
	
	Private Sub instantiate()
		Dim configdoc As NotesDocument
		
		Dim chunks As Variant 
		Dim targetserver As String
		Dim targetfilepath As String
		
		If Me.isInstantiating Then GoTo ExitPoint
		
		Set me.buffer = New EnhancedLogEntryBuffer() 
		
		Me.isInstantiating = True
		chunks = Split(getCurrentSession.NotesVersion, "|")
		ForAll element In chunks 
			element = Trim$(CStr(element))
		End ForAll 
		Me.myNotesVersion = Join(chunks, "; ") & |; Build | & CStr(getCurrentSession().NotesBuildVersion)

		Me.Enabled = True
		Me.LogActions = True
		Me.LogErrors = True
		Me.LogMethodResults = True
		Me.LogStackExceptions = False
		Me.LogWarnings = True
		Me.LocalEcho = False
		Me.AutoSave = False
		Me.OverwriteFile = False
		Me.ResumeOnLoggingFailure = False
		Me.ActionsIncludeMethodNames = True

		Set Me.ndtStartTime = New NotesDateTime(Now)	
		Set Me.targetDb_ = getCurrentDb()
		Set Me.nagt = getCurrentSession().CurrentAgent
		If (Me.nagt Is Nothing) Then
			Me.progName$ = getCallingUIobjectName()
			Me.agentOwner$ = Trim$(getCurrentSession().EffectiveUserName)
		Else
			Me.progName$ = Trim$(nagt.Name)
			Me.agentOwner$ = Trim$(nagt.Name)
		End If 

		Set configdoc = enhLogGetLogConfigDoc(False)
		If (Not (configdoc Is Nothing)) Then 
			Me.LogActions = (|Yes| = getDocItemText(configdoc, ITEMNAME_ENHLOG_YN_LOGACTIONS))
			Me.LogActions = (|Yes| = getDocItemText(configdoc, ITEMNAME_ENHLOG_YN_LOGACTIONS))
			Me.LogErrors = (|Yes| = getDocItemText(configdoc, ITEMNAME_ENHLOG_YN_LOGERRORS))
			Me.LogMethodResults = (|Yes| = getDocItemText(configdoc, ITEMNAME_ENHLOG_YN_LOGMETHODRESULTS))
			Me.LogStackExceptions = (|Yes| = getDocItemText(configdoc, ITEMNAME_ENHLOG_YN_LOGSTACKEXCEPTIONS))
			Me.LocalEcho = (|Yes| = getDocItemText(configdoc, ITEMNAME_ENHLOG_YN_LOCALECHO))
			Me.AutoSave = (|Yes| = getDocItemText(configdoc, ITEMNAME_ENHLOG_YN_AUTOSAVE))
			Me.OverwriteFile = (|Yes| = getDocItemText(configdoc, ITEMNAME_ENHLOG_YN_OVERWRITE))
			Me.ResumeOnLoggingFailure = (|Yes| = getDocItemText(configdoc, ITEMNAME_ENHLOG_YN_RESUMEONFAIL))
			Me.ActionsIncludeMethodNames = (|Yes| = getDocItemText(configdoc, ITEMNAME_ENHLOG_YN_INCLUDEMETHODNAMES))
			Me.LogWarnings = (|Yes| = getDocItemText(configdoc, ITEMNAME_ENHLOG_YN_LOGWARNINGS))
			Me.Enabled = (|Yes| = getDocItemText(configdoc, ITEMNAME_ENHLOG_YN_LOGENABLED))
			targetserver$ = getDocItemText(configdoc, ITEMNAME_ENHLOG_TARGET_SERVER)
			targetfilepath$ = getDocItemText(configdoc, ITEMNAME_ENHLOG_TARGET_FILEPATH)
			If ((Len(targetserver$) + Len(targetfilepath$)) > 0) Then Set Me.targetDb_ = getOpenDatabase(targetserver$, targetfilepath$) 
			If (Me.targetDb_ Is Nothing) Then Set Me.targetDb_ = getCurrentDb()
			Me.hasLogConfigDoc = True
		End If 

		Me.exists = True

	ExitPoint:
		Exit Sub
	End Sub 
	
	
	Public Sub Delete()
		Call Me.Close()
	End Sub 
	
	
	Public Sub Close()
		If Me.hasEntries Then 
			me.LogMethodResult |LotusScript Finished|
			Call me.dumpBuffer() 
			
			Call Me.LogProfiledMethodSummary()  
			
			Select Case me.logType 
				Case LOGTYPE_MAIL: 
					Call Me.Send() 
					
				Case LOGTYPE_AGENT:
					If Not (Me.nlog_ Is Nothing) Then
						Call Me.nlog_.Close()
						Set Me.nlog_ = Nothing
					End If 
	
				Case LOGTYPE_NOTES: 
					Call Me.Save(False, False)
					
				Case LOGTYPE_FILE: 
					Call Me.Save(False, False)
					If (0 <> Me.targetfilehandle_%) Then Close #Me.targetfilehandle_% 
			End Select
		End If 
	End Sub 
	
	
	%REM
		Property Get TargetDocument
		Target Log Document 
	%END REM
	Private Property Get TargetDocument As NotesDocument 
		If (Me.ndoc_ Is Nothing) Then Call me.createLogDoc() 
		Set TargetDocument = Me.ndoc_
	End Property
	
	
	Public Function AppendAsDocLink (source As NotesDocument, ByVal fieldname$, linkcomment$, hotspottext$) As Boolean
		
		Dim body As Variant		
		Dim extendedInfo As String
		Dim result As Boolean
		
		If (Not Me.exists) Then GoTo ExitPoint
		
		
		' Throw error to calling code.
		If (Me.logType = LOGTYPE_FILE) Then Error ERR_OPERATION_FAILED, _ 
		MSG_OPERATION_FAILED & |Currently logging to external file.  | & _ 
		|No Log Document exists from which to create a DocLink.|
		
		' Activate internal error handling
		On Error GoTo ErrorTrap
		
		If (Len(Trim$(fieldname$)) = 0) Then fieldname$ = ITEMNAME_BODY
		
		If (Me.TargetDocument Is Nothing) Then GoTo ExitPoint  
		
		If (Not Me.Save(True, False)) Then 
			extendedInfo$ = |Could not save Log Document.|
			Error ERR_OPERATION_FAILED, MSG_OPERATION_FAILED
		End If 
		
		If source.HasItem(fieldname$) Then
			Set body = source.GetFirstItem(fieldname$)
			If (Not (body.Type = RICHTEXT)) Then 
				extendedInfo$ = |Cannot append DocLink to NON-RICHTEXT item "| & _ 
				fieldname$ & |".|
				Error ERR_OPERATION_FAILED, MSG_OPERATION_FAILED				
			End If 
		Else
			Set body = New NotesRichTextItem(source, fieldname$)
		End If 
		
		If (Len(Trim$(hotspottext)) = |0|) Then
			body.AppendDocLink Me.TargetDocument, linkcomment$
		Else
			body.AppendDocLink Me.TargetDocument, linkcomment$, hotspottext$
		End If 
		
		' If here then no error occurred
		result = True

ExitPoint:
		Exit Function
ErrorTrap:
		On Error GoTo 0
		result = False
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage	
	End Function 
	
	
	Public Sub ClearCachedError()
		Erase Me.cachedErrors
		Me.countCachedErrors = 0
	End Sub 
	
	
	Public Sub LogAction (description$)
		Dim nitm As NotesItem
		On Error GoTo ErrorTrap
		
		Dim entry As EnhancedLogEntry 
		
		If (Not Me.exists) Then GoTo ExitPoint
		If (Not Me.LogActions) Then GoTo ExitPoint
		
		If me.buffer.isFull Then Call me.dumpBuffer() 
		
		Set entry = New EnhancedLogEntry(LOGENTRY_TYPE_ACTION, description$, ||, Nothing, ||, ||, 0, ||, 0, ||, Nothing)
		Call me.buffer.addEntry(entry)

ExitPoint:
		Exit Sub
ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage		
	End Sub 
	
	
	Public Sub LogActionWithLink (description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$)
		On Error GoTo ErrorTrap
		
		Dim entry As EnhancedLogEntry 

		If (Not Me.exists) Then GoTo ExitPoint
		If (Not Me.LogActions) Then GoTo ExitPoint

		If me.buffer.isFull Then Call me.dumpBuffer() 
		
		Set entry = New EnhancedLogEntry(LOGENTRY_TYPE_ACTION, description$, ||, linkTo, linkcomment$, HotSpotText$, 0, ||, 0, ||, Nothing)
		Call me.buffer.addEntry(entry)

ExitPoint:
		Exit Sub
ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage		
	End Sub 
	
	
	Public Sub LogError (code%, description$)
		Me.LogException code%, description$, Erl(), GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||
	End Sub 

	%REM
		Adds a StackTace to the log. 
	%END REM
	Public Sub LogStackTrace

		Dim entry As EnhancedLogEntry 
		Dim stacktrace As New EnhancedLogStackTrace()

		On Error GoTo ErrorTrap
		
		If (Not Me.exists) Then GoTo ExitPoint

		If me.buffer.isFull Then Call me.dumpBuffer()
		
		Set entry = New EnhancedLogEntry(LOGENTRY_TYPE_ACTION, ||, ||, Nothing, ||, ||, 0, ||, 0, ||, stacktrace)
		Call me.buffer.addEntry(entry)
		
ExitPoint:
		Exit Sub
ErrorTrap:
		On Error GoTo 0
		Me.LogStackExceptions = False
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage		
	End Sub 
	
	
	%REM 
		Sub LogEvent 
		Sends a Domino® event to the network. 
		
		@param message$ 	The message to send to the network.
		@param queuename$	The name of the queue. Domino picks a queue if you send an empty string ("").
		@param type% 		Indicates the kind of event being logged. May be any of the following: 
				 			EV_ALARM 		(8)
							EV_COMM 		(1)
							EV_MAIL 		(3)
							EV_MISC 		(6)
							EV_REPLICA 		(4)
							EV_RESOURCE 	(5)
							EV_SECURITY 	(2)
							EV_SERVER 		(7)
							EV_UNKNOWN 		(0)
							EV_UPDATE 		(9)
							
		@param severity% 	Indicates the severity of the event being logged. May be any of the following:
							SEV_FAILURE 	(2)
							SEV_FATAL 		(1)
							SEV_NORMAL 		(5)
							SEV_WARNING1 	(3)
							SEV_WARNING2 	(4)
	%END REM
	Public Sub LogEvent (message$, queuename$, eventType%, severity%)
		On Error GoTo ErrorTrap
		
		Dim extended$ 
		
		If (Not Me.exists) Then GoTo ExitPoint
		If (Me.nlog_ Is Nothing) Then Set Me.nlog_ = New NotesLog(Me.ProgramName)
		
		If Not getCurrentSession().IsOnServer Then Error ERR_OPERATION_FAILED, _ 
		MSG_OPERATION_FAILED & |LogEvent cannot be used by client-side code.|
		
		enhLogExtendedContent CLASS_PREFIX, |Sending Domino event to the network.|, _ 
		|message  = "| & message$ & |"| 
		
		enhLogExtendedContent ||, ||, |queuename = "| & queuename$ & |"|
		enhLogExtendedContent ||, ||, |eventType = | & CStr(eventType%)
		enhLogExtendedContent ||, ||, |eventType = | & CStr(severity%)
		
		Call Me.nlog_.LogEvent(message$, queuename$, eventType%, severity%)
		
ExitPoint:
		Exit Sub
ErrorTrap:
		On Error GoTo 0
		extended$ = |"| & queuename$ & |", "| & CStr(eventType%) & |, | & CStr(severity%)
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), extended$) Then 
			enhLogException CLASS_PREFIX, |("| & message$ & |", | & extended$ & |)|
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If 		
	End Sub 
	
	
	Public Sub LogException (code%, errMsg$, errline&, methodname$, description$)
		Dim entry As EnhancedLogEntry 
		Dim stacktrace As EnhancedLogStackTrace 

		On Error GoTo ErrorTrap
		
		If (Not Me.exists) Then GoTo ExitPoint
		If (Not Me.LogActions) Then GoTo ExitPoint

		If me.buffer.isFull Then Call me.dumpBuffer()
		
		Set stackTrace = Nothing 
		If Me.LogStackExceptions Then Set stackTrace = New EnhancedLogStackTrace() 
		
		Set entry = New EnhancedLogEntry(LOGENTRY_TYPE_EXCEPTION, description$, ||, Nothing, ||, ||, code%, errMsg$, errline&, methodname$, stacktrace)
		Call me.buffer.addEntry(entry)
		
ExitPoint:
		Exit Sub
ErrorTrap:
		On Error GoTo 0
		Me.LogStackExceptions = False
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage		
	End Sub 
	
	
	Public Sub LogExceptionWithLink (code%, errMsg$, errline&, methodname$, description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$) 
		Dim entry As EnhancedLogEntry 
		Dim stacktrace As EnhancedLogStackTrace 

		On Error GoTo ErrorTrap
		
		If (Not Me.exists) Then GoTo ExitPoint
		If (Not Me.LogActions) Then GoTo ExitPoint

		If me.buffer.isFull Then Call me.dumpBuffer()
		
		Set stackTrace = Nothing 
		If Me.LogStackExceptions Then Set stackTrace = New EnhancedLogStackTrace() 
		
		Set entry = New EnhancedLogEntry(LOGENTRY_TYPE_EXCEPTION, description$, ||, linkTo, linkcomment$, HotSpotText$, code%, errMsg$, errline&, methodname$, stacktrace)
		Call me.buffer.addEntry(entry)
		
ExitPoint:
		Me.myHasLinkInfo = False
		Exit Sub
ErrorTrap:
		On Error GoTo 0
		Me.LogStackExceptions = False
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage		
	End Sub 
	
	
	
	Public Sub LogExtendedContent (description$, extendedcontent$)
		Dim nitm As NotesItem
		On Error GoTo ErrorTrap
		
		Dim entry As EnhancedLogEntry 
		
		If (Not Me.exists) Then GoTo ExitPoint
		If (Not Me.LogActions) Then GoTo ExitPoint
		
		If me.buffer.isFull Then Call me.dumpBuffer() 
		
		Set entry = New EnhancedLogEntry(LOGENTRY_TYPE_EXTENDED, description$, extendedcontent$, Nothing, ||, ||, 0, ||, 0, ||, Nothing)
		Call me.buffer.addEntry(entry)

ExitPoint:
		Exit Sub
ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage		
	End Sub 
	
	
	Public Sub LogExtendedContentWithLink (description$, extendedcontent$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$)
		On Error GoTo ErrorTrap
		
		Dim entry As EnhancedLogEntry 

		If (Not Me.exists) Then GoTo ExitPoint
		If (Not Me.LogActions) Then GoTo ExitPoint

		If me.buffer.isFull Then Call me.dumpBuffer() 
		
		Set entry = New EnhancedLogEntry(LOGENTRY_TYPE_EXTENDED, description$, extendedcontent$, linkTo, linkcomment$, HotSpotText$, 0, ||, 0, ||, Nothing)
		Call me.buffer.addEntry(entry)

ExitPoint:
		Exit Sub
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage		
	End Sub 

	
	

	
	Public Sub LogMethodResult (description$)
		On Error GoTo ErrorTrap
		
		Dim entry As EnhancedLogEntry 

		If (Not Me.exists) Then GoTo ExitPoint
		If (Not Me.LogActions) Then GoTo ExitPoint

		If me.buffer.isFull Then Call me.dumpBuffer() 
		
		Set entry = New EnhancedLogEntry(LOGENTRY_TYPE_METHODRESULT, description$, ||, Nothing, ||, ||, 0, ||, 0, ||, Nothing)
		Call me.buffer.addEntry(entry)

	ExitPoint:
		Exit Sub
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage	
	End Sub 
	

	Public Sub LogMethodResultWithLink (description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$)
		On Error GoTo ErrorTrap
		
		Dim entry As EnhancedLogEntry 

		If (Not Me.exists) Then GoTo ExitPoint
		If (Not Me.LogActions) Then GoTo ExitPoint

		If me.buffer.isFull Then Call me.dumpBuffer() 
		
		Set entry = New EnhancedLogEntry(LOGENTRY_TYPE_METHODRESULT, description$, ||, linkTo, linkcomment$, HotSpotText$, 0, ||, 0, ||, Nothing)
		Call me.buffer.addEntry(entry)

	ExitPoint:
		Exit Sub
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage		
	End Sub 



	Private Sub LogProfiledMethodSummary()
		On Error GoTo ErrorTrap

		Const DESCRIP_PREV = |Profiled Method Summary  |
		Const COMMENT_PREV = |Link to Previous Log document.  |
		Const DESCRIP_NEXT = |A Profiled Method Summary has been generated.  |
		Const COMMENT_NEXT = |Link to Profiled Method Summary document.  |

		Dim ndocTempOld As NotesDocument
		Dim ndocTempNew As NotesDocument
		Dim nitm As NotesItem 
		Dim stream As NotesStream 
		
		If doLogOutputToNotesLog _ 
		Or (Not enhLogIsProfilingEnabled()) _ 
		Or (Not genhl_ProfiledMethods.hasContent) _  
		Or (Me.isSpanningLogDocs _ 
		Or (Me.logType <> LOGTYPE_NOTES)) _  
		Then GoTo ExitPoint 
		
		
		If Me.spanLogDocument(|Log document.  |, _ 
		|Link to Previous document.  |, _ 
		|A Profiled Method Summary has been generated.  |, _ 
		|Link to Profiled Method Summary document.  |) Then  
			
			Call Me.SetXMLcontent()
			
			Set stream = enhLogGetProfiledMethodsXMLstream(False)
			If (Not (stream Is Nothing)) Then
				stream.Position = 0
				Me.xmlnrti_.AppendText |<?xml version="1.0"?>|
				Me.xmlnrti_.AddNewLine 1
				
				Do
					Me.xmlnrti_.AppendText stream.ReadText(STMREAD_LINE, EOL_NONE)
					Me.xmlnrti_.AddNewLine 1
				Loop Until stream.IsEOS 
				
				Set nitm = Me.TargetDocument.ReplaceItemValue(|A$HASXMLCONTENT|, 1)
				nitm.IsSummary = True
			End If 
		End If 
		
	ExitPoint:
		Exit Sub
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage	
	End Sub 


	Public Sub LogWarning (description$)
		On Error GoTo ErrorTrap
		
		Dim entry As EnhancedLogEntry 

		If (Not Me.exists) Then GoTo ExitPoint
		If (Not Me.LogActions) Then GoTo ExitPoint

		If me.buffer.isFull Then Call me.dumpBuffer() 
		
		Set entry = New EnhancedLogEntry(LOGENTRY_TYPE_WARNING, description$, ||, Nothing, ||, ||, 0, ||, 0, ||, Nothing)
		Call me.buffer.addEntry(entry)

	ExitPoint:
		Exit Sub
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage	
	End Sub 


	Public Sub LogWarningWithLink (description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$)
		On Error GoTo ErrorTrap
		
		Dim entry As EnhancedLogEntry 

		If (Not Me.exists) Then GoTo ExitPoint
		If (Not Me.LogActions) Then GoTo ExitPoint

		If me.buffer.isFull Then Call me.dumpBuffer() 
		
		Set entry = New EnhancedLogEntry(LOGENTRY_TYPE_WARNING, description$, ||, linkTo, linkcomment$, HotSpotText$, 0, ||, 0, ||, Nothing)
		Call me.buffer.addEntry(entry)

	ExitPoint:
		Exit Sub
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage				
	End Sub 
	
	Public Function OpenAgentLog() As Boolean
		OpenAgentLog = Me.ChangeLogType(LOGTYPE_AGENT, ||, ||)
	End Function 
	
	Public Function OpenFileLog(path$) As Boolean
		OpenFileLog = Me.ChangeLogType(LOGTYPE_FILE, ||, path$)
	End Function 
	
	
	Public Function OpenMailLog(recipients As Variant, ByVal subject$) As Boolean
		Dim extendedInfo As String
		Dim result As Boolean
		
		On Error GoTo ErrorTrap
		
		If isStringArrayEmpty(recipients) Then
			extendedInfo$ = |No entries found in recipients.|
			Error ERR_OPERATION_FAILED, MSG_OPERATION_FAILED
		End If 
		
		result = Me.ChangeLogType(LOGTYPE_MAIL, ||, ||)
		
		If result Then
			TrimString subject$
			If (Len(subject$) > 0) Then Me.Subject = subject$
			Me.varSendTo = recipients
		End If 
		
	ExitPoint:
		OpenMailLog = result
		Exit Function
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, extendedInfo$
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If 	
	End Function 
	
	
	
	Public Function OpenNotesLog (server$, dbfile$) As Boolean
		Dim extendedInfo As String
		Dim result As Boolean		
		On Error GoTo ErrorTrap
		
		extendedInfo$ = |LOGTYPE: | & lstrLogTypes(LOGTYPE_NOTES) & Chr(10) & _ 
		|Target Server: | & server$ & Chr(10) & _ 
		|Target Filepath: | & dbfile$		
		
		If (Not Me.ChangeLogType(LOGTYPE_NOTES, server$, dbfile$)) Then Error ERR_DATABASE_NOTOPEN, MSG_DATABASE_NOTOPEN
		
		' success!	
		result = True
		
	ExitPoint:		
		OpenNotesLog = result	
		Exit Function
	ErrorTrap:
		On Error GoTo 0
		result = False
		If (Me.targetDb_ Is Nothing) Then Set Me.targetDb_ = getCurrentDb()
		
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, extendedInfo$
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If 
	End Function 
	
	
	Public Function Save(force As Boolean, createResponse As Boolean) As Boolean
		Dim nitm As NotesItem

		Dim extendedInfo As String	

		Dim result As Boolean	
		Dim isRecursive As Boolean		

		On Error GoTo ErrorTrap
	
		isRecursive = (GetThreadInfo(LIB_LSI_THREAD_PROC) = GetThreadInfo(LIB_LSI_THREAD_CALLPROC))
		If isRecursive Then Me.saverecursions_ = Me.saverecursions_ + 1
		
		If (Not Me.exists) Then GoTo ExitPoint 
		
		Select Case Me.logType			
			Case LOGTYPE_NOTES:
				If (Me.TargetDocument Is Nothing) Then GoTo ExitPoint  
				Set nitm = Me.TargetDocument.ReplaceItemValue(|A$ENDTIME|, Now)
				nitm.IsSummary = True		
				
				If enhLogOutputToNotesLog Then 
					Set nitm = Me.TargetDocument.ReplaceItemValue(|FinishTime|, Now)
					nitm.IsSummary = True		
				End If 
				
				result = Me.TargetDocument.Save(force, createResponse)

			Case LOGTYPE_FILE: 
				If (0 <> Me.targetfilehandle_%) Then 
					Close #Me.targetfilehandle_% ' This saves the target file
					
					' Target file must be re-opened in append mode
					Me.targetfilehandle_% = FreeFile()
					Open Me.targetfilepath_$ For Append As targetfilehandle_%
				End If
			
			Case LOGTYPE_MAIL:
				result = True
				
				' TODO NEED TO COMPLETE THE SAVE CODE HERE
				
			Case LOGTYPE_AGENT: 
				' do nothing, agent logs are not saved.
				

		End Select 
		
		
	ExitPoint:
		If isRecursive Then Me.saverecursions_ = Me.saverecursions_ - 1
		Save = result
		Exit Function
	ErrorTrap:
		On Error GoTo 0
		result = False
		Me.LogStackExceptions = False
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, extendedInfo$
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If 
	End Function 
	
	
	
	Public Property Get ActionsIncludeMethodNames As Boolean
		ActionsIncludeMethodNames = Me.doActionsIncludeMethodNames
	End Property 
	
	Public Property Get AutoSave As Boolean
		AutoSave = Me.doAutoSave
	End Property 
	
	Public Property Get CachedErrorCode As Integer
		If IsElement(Me.cachedErrors(Me.countCachedErrors)) Then
			CachedErrorCode = Me.cachedErrors(Me.countCachedErrors).code%
		Else
			CachedErrorCode = 0
		End If 
	End Property 
	
	Public Property Get CachedErrorExtended As String
		If IsElement(Me.cachedErrors(Me.countCachedErrors)) Then
			CachedErrorExtended = Me.cachedErrors(Me.countCachedErrors).extended$
		Else
			CachedErrorExtended = ||
		End If 
	End Property 
	
	Public Property Get CachedErrorLine As Integer
		If IsElement(Me.cachedErrors(Me.countCachedErrors)) Then
			CachedErrorLine = Me.cachedErrors(Me.countCachedErrors).linenumber%
		Else
			CachedErrorLine = 0
		End If 
	End Property 
	
	Public Property Get CachedErrorMessage As String
		If IsElement(Me.cachedErrors(Me.countCachedErrors)) Then
			CachedErrorMessage = Me.cachedErrors(Me.countCachedErrors).message$
		Else
			CachedErrorMessage = ||
		End If 
	End Property 
	
	Public Property Get CachedErrorMethod As String
		If IsElement(Me.cachedErrors(Me.countCachedErrors)) Then
			CachedErrorMethod = Me.cachedErrors(Me.countCachedErrors).methodname$
		Else
			CachedErrorMethod = ||
		End If 
	End Property 
	
	Public Property Get CachedErrorTimestamp As String
		If IsElement(Me.cachedErrors(Me.countCachedErrors)) Then
			CachedErrorTimestamp = Me.cachedErrors(Me.countCachedErrors).timestamp$
		Else
			CachedErrorTimestamp = ||
		End If 
	End Property 

	Public Property Get Enabled As Boolean
		Enabled = Me.isLogEnabled		
	End Property 
	
	Public Property Get Filepath As String
		Filepath = Me.dbFilepath$
	End Property 
	
	Public Property Get hasActions As Boolean
		hasActions = me.buffer.hasACTION
	End Property 
	
	Public Property Get hasCachedError As Boolean
		hasCachedError = IsElement(Me.cachedErrors(Me.countCachedErrors))
	End Property 
	
	Public Property Get hasEntries As Boolean
		Dim result As Boolean 

		result = Me.buffer.hasACTION
		If Not result Then result = Me.buffer.hasEXCEPTION 
		If Not result Then result = Me.buffer.hasWARNING 
		
		hasEntries = result 
	End Property 
	
	Public Property Get hasErrors As Boolean
		hasErrors = Me.buffer.hasEXCEPTION
	End Property 
	
	Public Property Get hasWarnings As Boolean
		hasWarnings = Me.buffer.hasWARNING
	End Property 
	
	
	Public Property Get LastInternalErrorCode As Integer 
		Dim internalError As ErrorInfo 
		If (Me.internalErrorCount > 0) Then internalError = me.internalErrorStack(me.internalErrorCount -1) 
		LastInternalErrorCode = internalError.code  		
	End Property 

	Public Property Get LastInternalErrorMessage As String 
		Dim internalError As ErrorInfo 
		If (Me.internalErrorCount > 0) Then internalError = me.internalErrorStack(me.internalErrorCount -1) 
		LastInternalErrorMessage = internalError.message 			
	End Property 

	Public Property Get LocalEcho As Boolean
		LocalEcho = Me.doLocalEcho	
	End Property 
	
	Public Property Get LogActions As Boolean
		LogActions = Me.doLogActions		
	End Property 
	
	Public Property Get LogErrors As Boolean
		LogErrors = Me.doLogErrors
	End Property 
	
	Public Property Get LogMethodResults As Boolean
		LogMethodResults = Me.doLogMethodResults
	End Property 
	
	Public Property Get LogOutputToNotesLog As Boolean
		LogOutputToNotesLog = Me.doLogOutputToNotesLog
	End Property 
	
	Public Property Get LogStackExceptions As Boolean
		LogStackExceptions = Me.doLogStackExceptions
	End Property 
	
	Public Property Get LogWarnings As Boolean
		LogWarnings = Me.doLogWarnings		
	End Property 
	
	Public Property Get NotesLogForm As String
		NotesLogForm = FORMALIAS_EVENTS 
	End Property
	
	
	Public Property Get NumActions As Long
		NumActions = Me.buffer.countACTION
	End Property 
	
	Public Property Get NumErrors As Long
		NumErrors = Me.buffer.countEXCEPTION
	End Property 
	
	Public Property Get NumWarnings As Long
		NumWarnings = Me.buffer.countWARNING
	End Property 
	
	Public Property Get OverwriteFile As Boolean
		OverwriteFile = Me.doOverwriteFile
	End Property 
	
	Public Property Get Parent As NotesSession
		Set Parent = getCurrentSession()
	End Property 
	
	Public Property Get ProgramName As String
		ProgramName = Me.progName$
	End Property 
	
	Public Property Get ResumeOnLoggingFailure As Boolean
		ResumeOnLoggingFailure = Me.doResumeOnLoggingFailure
	End Property 
	
	Public Property Get SendTo As Variant
		If (Me.logType = LOGTYPE_MAIL) Then
			SendTo = Me.varSendTo
		Else
			SendTo = ||
		End If 
	End Property 
	
	Public Property Get Server As String
		Server = Me.dbServer$
	End Property 
	
	Public Property Get StartTime As NotesDateTime
		If (Me.ndtStartTime Is Nothing) Then Set Me.ndtStartTime = New NotesDateTime(Now)
		Set StartTime = Me.ndtStartTime		
	End Property 
	
	%REM
		Property Get StartTimestamp
		Formatted timestamp indicating when the object was instantiated
	%END REM
	Public Property Get StartTimestamp As String 
		If isBlankString(me.starttimestamp_) Then me.starttimestamp_ = Format$(me.StartTime.Lslocaltime, FORMAT_TIMESTAMP) 
		StartTimestamp = me.starttimestamp_
	End Property
	
	
	Public Property Get Subject As String
		Subject = Me.mySubject
	End Property 
	
	Public Property Get TargetDatabase As NotesDatabase
		Dim result As NotesDatabase
		On Error GoTo ErrorTrap
		
		If (Me.targetDb_ Is Nothing) Then Error ERR_MISSING_DATABASE, MSG_MISSING_DATABASE
		
	ExitPoint:
		Set TargetDatabase = Me.targetDb_
		Exit Property
	ErrorTrap:
		On Error GoTo 0
		Set Me.targetDb_ = getCurrentDb()
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, ||
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If 	
	End Property 
	
	Public Property Get UserName As NotesName
		If (Me.nnamUser Is Nothing) Then Set Me.nnamUser = Me.BuildUserName()
		Set UserName = Me.nnamUser
	End Property 
	
	Public Property Get UserNameAbbrev As String
		If (Me.nnamUser Is Nothing) Then Set Me.nnamUser = Me.BuildUserName()
		UserNameAbbrev = Me.abbrevUserName$
	End Property 
	
	Public Property Set ActionsIncludeMethodNames As Boolean
		Me.doActionsIncludeMethodNames = ActionsIncludeMethodNames
	End Property 
	
	Public Property Set AutoSave As Boolean
		Me.doAutoSave = AutoSave	
		If Me.doAutoSave Then _ 
		Me.LogExtendedContent CLASS_PREFIX & |AutoSave set to: True|, _ 
		|Called by: | & GetThreadInfo(LIB_LSI_THREAD_CALLPROC) & |()| 
	End Property 

	Public Property Set Enabled As Boolean
		If Me.hasLogConfigDoc Then Exit Property
		Me.isLogEnabled = Enabled
		If (Not Me.isLogEnabled) Then 
			Me.LogActions = False
			Me.LogErrors = False
			Me.LogMethodResults = False
			Me.LogStackExceptions = False
			Me.LogWarnings = False
			Me.LocalEcho = False
			Me.AutoSave = False
			Me.OverwriteFile = False
			Me.ResumeOnLoggingFailure = False
			Me.ActionsIncludeMethodNames = False
		End If 
	End Property 
	
	
	Public Property Set LocalEcho As Boolean
		If getCurrentSession().IsOnServer Then 
			Me.doLocalEcho = False
		Else
			Me.doLocalEcho = LocalEcho
		End If 
	End Property 
	
	Public Property Set LogActions As Boolean
		If Me.hasLogConfigDoc Then Exit Property
		Me.doLogActions = LogActions	
	End Property 
	
	Public Property Set LogErrors As Boolean
		If Me.hasLogConfigDoc Then Exit Property
		Me.doLogErrors = LogErrors	
	End Property 
	
	Public Property Set LogMethodResults As Boolean
		If Me.hasLogConfigDoc Then Exit Property
		Me.doLogMethodResults = LogMethodResults	
	End Property 
	
	Public Property Set LogOutputToNotesLog As Boolean
		Me.doLogOutputToNotesLog = LogOutputToNotesLog	
	End Property 
	
	Public Property Set LogStackExceptions As Boolean
		If Me.hasLogConfigDoc Then Exit Property
		Me.doLogStackExceptions = LogStackExceptions
	End Property 
	
	Public Property Set LogWarnings As Boolean
		If Me.hasLogConfigDoc Then Exit Property
		Me.doLogWarnings = LogWarnings	
	End Property 
	
	Public Property Set OverwriteFile As Boolean
		Me.doOverwriteFile = OverwriteFile	
	End Property 
	
	Public Property Set ProgramName As String
		Dim nitm As NotesItem
		If (Me.TargetDocument Is Nothing) Then Exit Property
		
		Me.progName$ = ProgramName
		Set nitm = Me.TargetDocument.ReplaceItemValue(|A$PROGNAME|, Me.progName$)
	End Property 
	
	Public Property Set ResumeOnLoggingFailure As Boolean
		Me.doResumeOnLoggingFailure = ResumeOnLoggingFailure	
	End Property 
	
	Public Property Set SendTo As Variant
		Dim sourceType As String
		
		If Not (Me.logType = LOGTYPE_MAIL) Then Error ERR_OPERATION_FAILED, _ 
		MSG_OPERATION_FAILED & | Singleton object was not opened as a MailLog.|
		
		sourceType$ = TypeName(SendTo)
		If Not ((sourceType$ = |STRING|) Or (sourceType$ = |STRING( )|)) Then _ 
		Error ERR_PARAMETER_INVALID, MSG_PARAMETER_INVALID & _ 
		|SendTo must be either a String or an array of Strings.  SendTo type: | & _ 
		sourceType$ & |.|
		
		Me.varSendTo = SendTo
	End Property 
	
	Public Property Set Subject As String
		Dim nitm As NotesItem
		If (Me.TargetDocument Is Nothing) Then Exit Property
		
		Set nitm = Me.TargetDocument.ReplaceItemValue(|Subject|, Subject)
		nitm.IsSummary = True
		Me.mySubject$ = Subject		
	End Property 
	
	Public Property Set UserName As NotesName
		If Not (UserName Is Nothing) Then 
			Set Me.nnamUser = UserName
			Me.abbrevUserName$ = Me.nnamUser.Abbreviated
		End If 
	End Property 
	
	Public Property Set UserNameAbbrev As String
		UserNameAbbrev = Trim$(UserNameAbbrev)
		If (UserNameAbbrev <> ||) Then 
			Set Me.nnamUser = New NotesName(UserNameAbbrev)
			Me.abbrevUserName$ =Me. nnamUser.Abbreviated
		End If 
	End Property 
	
	Private Sub AddTimestamp (nrtstyle As NotesRichTextStyle)
		Me.nrti_.AppendStyle nrtstyle
		Me.nrti_.AppendText Format$(Now, FORMAT_TIMESTAMP) & | |
	End Sub 
	
	
	Private Sub AppendDocLink (linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$) 
		Dim linkToType As String
		Dim isValidLinkType As Boolean
		On Error GoTo ErrorTrap
		
		If (linkTo Is Nothing) Then GoTo ExitPoint
		If (Me.logType = LOGTYPE_FILE) Then GoTo ExitPoint
		
		linkToType$ = TypeName(linkTo)
		Select Case linkToType$
			Case |NOTESDATABASE|, |NOTESVIEW|, |NOTESDOCUMENT|
				isValidLinkType = True
			Case Else
				isValidLinkType = False
		End Select 	
		
		If Not isValidLinkType Then Error ERR_PARAMETER_INVALID, _ 
		MSG_PARAMETER_INVALID & |Invalid Link Type: "| & linkToType$ & |".|
		
		TrimString linkcomment$
		TrimString HotSpotText$
		Me.nrti_.AppendText | |
		
		If isBlankString(HotSpotText$) Then
			Me.nrti_.AppendDocLink linkTo, linkcomment$
		Else
			Me.nrti_.AppendDocLink linkTo, linkcomment$, HotSpotText$
		End If 
		Me.nrti_.AppendText | |
		
	ExitPoint:
		Me.myHasLinkInfo = False
		Exit Sub
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, ||
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If 	
	End Sub 
	
	
	Private Function BuildUserName As NotesName
		Dim nsesEffectiveUserName As String
		Dim nnam As NotesName
		
		nsesEffectiveUserName = getCurrentSession().EffectiveUserName
		
		If getCurrentSession().IsOnServer Then 
			If (nsesEffectiveUserName = Me.agentOwner$) Then
				Set nnam = New NotesName(getCurrentSession().UserName)
			Else
				Set nnam = New NotesName(nsesEffectiveUserName)
			End If 
		Else
			Set nnam = New NotesName(getCurrentSession().UserName)
		End If 
		
		abbrevUserName$ = nnam.Abbreviated
		
		Set BuildUserName = nnam
	End Function 
	
	
	Private Function ChangeLogType(newLogType As Byte, ByVal server$, path$) As Boolean 
		Dim extendedInfo As String
		Dim result As Boolean
		On Error GoTo ErrorTrap

		Dim ndbOld As NotesDatabase
		Dim ndbNew As NotesDatabase
		Dim ndocOld As NotesDocument
		Dim nnamNew As NotesName
		Dim nnamOld As NotesName
		Dim isLogSame As Boolean

		TrimString server$
		TrimString path$
		
		Set ndbOld = Me.targetDb_
		Set ndocOld = Me.ndoc_
		
		If Not IsElement(lstrLogTypes(newLogType)) Then 
			extendedInfo$ = |Invalid Log Type: (| & CStr(newLogType) & |)| & Chr(10) 
			Error ERR_PARAMETER_INVALID, MSG_PARAMETER_INVALID
		End If 
		
		' Close the previous log
		If Me.hasEntries Then 
			enhLogAction CLASS_PREFIX, |Changing from  | & _ 
			lstrLogTypes(Me.logType) & | to | & lstrLogTypes(newLogType) & |.|

			If Not (Me.targetDb_ Is Nothing) Then 
				server$ = Me.targetDb_.Server 
				If isBlankString(server$) Then 
					enhLogAction CLASS_PREFIX, |Closing | & lstrLogTypes(Me.logType) & |: [LocalClient]!!| & Me.targetDb_.Filepath
				Else 
					enhLogAction CLASS_PREFIX, |Closing | & lstrLogTypes(Me.logType) & |: | & server$ & |!!| & Me.targetDb_.Filepath
				End If  
			End If 
		End If 

		
		Select Case Me.LogType
			Case LOGTYPE_AGENT
				If Not (Me.nlog_ Is Nothing) Then Me.nlog_.Close
				Set Me.nlog_ = Nothing
				If Me.hasEntries Then Me.Save False, False
				
			Case LOGTYPE_FILE
				If (0 <> Me.targetfilehandle_%) Then 
					Close #Me.targetfilehandle_%	
					Me.targetfilehandle_% = 0
				End If 	

			Case LOGTYPE_MAIL
				If Me.hasEntries Then Me.Send
				
			Case LOGTYPE_NOTES
				' Notes Log document and database are intentionally NOT closed here.
				' This is so exceptions can be logged if something goes horribly wrong 
				' when opening the new log type.
				If Me.hasEntries Then Me.Save False, False
		End Select 	
		
		
		' Open the new log
		Select Case newLogType
			Case LOGTYPE_AGENT
				If (Me.nlog_ Is Nothing) Then Set Me.nlog_ = New NotesLog(Me.ProgramName)
				Me.nlog_.OpenAgentLog
				Me.nlog_.LogAction lstrLogTypes(Me.logType) & | opened.|
				
			Case LOGTYPE_FILE
				If isBlankString(path$) Then path$ = FILEPATH_ENHANCEDLOG_FILE(me.ProgramName & |_|)
				If (Right$(LCase$(path$), 4) = |.nsf|) Then
					extendedInfo$ = |Cannot open | & lstrLogTypes(newLogType) & _ 
					| with filepath of "| & path$ & |".|
					Error ERR_PARAMETER_INVALID, MSG_PARAMETER_INVALID
				End If 				

				If (0 = Me.targetfilehandle_%) Then
					Me.targetfilepath_$ = path$
					Me.targetfilehandle_% = FreeFile()
					Open Me.targetfilepath_$ For Output As targetfilehandle_%
				End If

				Call Me.AddBodyHeader_File() 
				Print #Me.targetfilehandle_%, me.StartTimestamp & |  LotusScript Started|				

			Case LOGTYPE_MAIL
				' do nothing 
				
			Case LOGTYPE_NOTES
				If Not (Me.targetDb_ Is Nothing) Then 
					If isBlankString(server$) Then server$ = Me.targetDb_.Server 
					Set nnamOld = New NotesName(Me.targetDb_.Server) 
				End If
				
				Set nnamNew = New NotesName(server$)
				If (Me.LogType = LOGTYPE_NOTES) Then 
					If Not (Me.targetDb_ Is Nothing) Then 
						isLogSame = (LCase$(Me.targetDb_.FilePath) = path$) And  ((LCase$(nnamOld.Abbreviated) = LCase$(nnamNew.Abbreviated))) 
					End If
				End If

				If (Not isLogSame) Then
					Set ndbNew = getOpenDatabase(server$, path$)
					If (ndbNew Is Nothing) Then GoTo ExitPoint
					
					Set Me.targetDb_ = ndbNew
					Call Me.createLogDoc()
					
					server$ = Me.targetDb_.Server 
					If isBlankString(server$) Then 
						enhLogAction CLASS_PREFIX, |Opened NotesLog: [LocalClient]!!| & Me.targetDb_.Filepath
					Else 
						enhLogAction CLASS_PREFIX, |Opened NotesLog: | & server$ & |!!| & Me.targetDb_.Filepath
					End If  
				End If 
		End Select 	
		
		Me.logType = newLogType
		result = True
		
	ExitPoint:
		ChangeLogType = result
		Exit Function
	ErrorTrap:
		On Error GoTo 0

		result = False
		Set Me.targetDb_ = ndbOld
		Set Me.ndoc_ = ndocOld
		
		%REM
			Explicity change to LOGTYPE_NOTES to ensure that this exception is logged for later analysis.
		%END REM
		Me.logType = LOGTYPE_NOTES
		If Not (Me.ndoc_ Is Nothing) Then Me.ndoc_.Form = enhLogGetNotesLogForm()
		
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, extendedInfo$
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If 
	End Function 
	
	
	Private Function createLogDoc() As Boolean
		Dim subject As String
		
		Dim result As Boolean 
		
		On Error GoTo ErrorTrap
		
		Set Me.ndoc_ = generateLogDoc(Me.acl, Me.targetDb_, Me.UserName, Me.UserRoles, Me.StartTime, Me.progName$, Me.dbServer$, Me.dbTitle$, Me.dbFilepath$, subject$, Me.myNotesVersion$, Me.ResumeOnLoggingFailure) 
		If (Me.ndoc_ Is Nothing) Then GoTo ExitPoint 

		me.hasLoggedAction = False 
		me.hasLoggedException = False 
		me.hasLoggedWarning = False 	

		Me.Subject = subject$
		
		Call Me.setBody() 
		If Me.AutoSave Then enhLogAction CLASS_PREFIX, |Created Log Doc (AutoSave: True)|
		
		result = True ' success
		
	ExitPoint:
		createLogDoc = result
		Exit Function
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, ||
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If 
	End Function 
	
	
	Private Sub initializeRTStyles()
		Dim ses As NotesSession

		If (Me.nrtstyleTimestampNormal Is Nothing) Then _ 
		Set Me.nrtstyleTimestampNormal = createRichTextStyle(True, EFFECTS_NONE, 8, _ 
		False, COLOR_BLACK, FONT_COURIER, False, False, False)
		
		If (Me.nrtstyleTimestampError Is Nothing) Then _ 
		Set Me.nrtstyleTimestampError = createRichTextStyle(True, EFFECTS_NONE, 8, _ 
		False, COLOR_RED, FONT_COURIER, False, False, False)
		
		If (Me.nrtstyleTimestampExtended Is Nothing) Then _ 
		Set Me.nrtstyleTimestampExtended = createRichTextStyle(True, EFFECTS_NONE, 8, _ 
		False, COLOR_DARK_BLUE, FONT_COURIER, False, False, False)
		
		If (Me.nrtstyleTimestampWarning Is Nothing) Then _ 
		Set Me.nrtstyleTimestampWarning = createRichTextStyle(True, EFFECTS_NONE, 8, _ 
		False, COLOR_DARK_MAGENTA, FONT_COURIER, False, False, False)
		
		If (Me.nrtstyleAction Is Nothing) Then _ 
		Set Me.nrtstyleAction = createRichTextStyle(False, EFFECTS_NONE, 9, _ 
		False, COLOR_BLACK, FONT_HELV, False, False, False)
		
		If (Me.nrtstyleMethodResult Is Nothing) Then _ 
		Set Me.nrtstyleMethodResult = createRichTextStyle(False, EFFECTS_NONE, 9, _ 
		False, COLOR_DARK_CYAN, FONT_HELV, False, False, False)
		
		If (Me.nrtstyleError Is Nothing) Then _ 
		Set Me.nrtstyleError = createRichTextStyle(True, EFFECTS_NONE, 9, _ 
		False, COLOR_RED, FONT_HELV, False, False, False)
		
		If (Me.nrtstyleErrorExtended Is Nothing) Then _ 
		Set Me.nrtstyleErrorExtended = createRichTextStyle(False, EFFECTS_NONE, 9, _ 
		False, COLOR_RED, FONT_HELV, False, False, False)
		
		If (Me.nrtstyleExtendedContent Is Nothing) Then _ 
		Set Me.nrtstyleExtendedContent = createRichTextStyle(False, EFFECTS_NONE, 9, _ 
		False, COLOR_DARK_BLUE, FONT_HELV, False, False, False)
		
		If (Me.nrtstyleWarning Is Nothing) Then _ 
		Set Me.nrtstyleWarning = createRichTextStyle(True, EFFECTS_NONE, 9, _ 
		False, COLOR_DARK_MAGENTA, FONT_HELV, False, False, False)

		If (Me.nrtstyleTableHeader Is Nothing) Then _ 
		Set Me.nrtstyleTableHeader = createRichTextStyle(False, EFFECTS_NONE, 12, _ 
		False, COLOR_BLACK, FONT_COURIER, False, False, False)

		If (Me.nrtstyleTableHeaderLabel Is Nothing) Then _ 
		Set Me.nrtstyleTableHeaderLabel = createRichTextStyle(True, EFFECTS_NONE, 12, _ 
		False, COLOR_DARK_BLUE, FONT_COURIER, False, False, False)

		If (Me.nrtstyleXMLcontent Is Nothing) Then _ 
		Set Me.nrtstyleXMLcontent = createRichTextStyle(False, EFFECTS_NONE, 8, _ 
		False, COLOR_BLACK, FONT_COURIER, False, False, False)
		
		If (Me.nrtparastyle Is Nothing) Then 
			Set ses = getCurrentSession() 
			Set Me.nrtparastyle = ses.CreateRichTextParagraphStyle() 
			Me.nrtparastyle.Alignment = ALIGN_LEFT 
			nrtparastyle.SetTabs 6, RULER_ONE_INCH * 2.5, RULER_ONE_CENTIMETER, TAB_DECIMAL
			nrtparastyle.SpacingAbove = SPACING_SINGLE
		End If 
	End Sub 
	
	
	Private Sub ResetDocument (target As NotesDocument)
		If (target Is Nothing) Then Exit Sub
		Set Me.ndoc_ = target
		Call Me.setBody()
	End Sub 
	
	
	Private Sub Send
		Dim nitm As NotesItem
		Dim sourceType$
		Dim extendedContent$
		
		On Error GoTo ErrorTrap
		
		If (Not Me.exists) Then GoTo ExitPoint
		If (Me.TargetDocument Is Nothing) Then GoTo ExitPoint  
		If Not (Me.logType = LOGTYPE_MAIL) Then GoTo ExitPoint 
		
		extendedcontent$ = |Attempting to send MailLog to: |
		sourceType$ = TypeName(Me.varSendTo)
		
		Select Case sourceType$
			Case |STRING|
				extendedcontent$ = extendedcontent$ & Me.varSendTo & |.|			
				
			Case |STRING( )|
				extendedcontent$ = extendedContent & Join(Me.varSendTo, |, |) & |.|
		End Select 	
		
		Set nitm = Me.TargetDocument.ReplaceItemValue(ITEMNAME_FORM, FORMNAME_MEMO)
		
		If Me.hasEntries Then enhLogAction CLASS_PREFIX, |Sending | & _ 
		lstrLogTypes(Me.logType)
		
		Me.Subject = Me.mySubject$
		Me.TargetDocument.Send False, Me.varSendTo
		
	ExitPoint:
		Exit Sub
	ErrorTrap:
		On Error GoTo 0
		
		%REM
			Explicity change (instead of calling ChangeLogType methodname) to LOGTYPE_NOTES 
			to ensure that this exception is logged for later analysis.
		%END REM
		Me.logType = LOGTYPE_NOTES 	 
		If Not (Me.ndoc_ Is Nothing) Then Me.ndoc_.Form = enhLogGetNotesLogForm()
		extendedcontent$ = extendedcontent$ & Chr(10) & _ 
		|Forced Log Type change to | & lstrLogTypes(LOGTYPE_NOTES) & |.|
		
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, extendedcontent$
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If 
	End Sub 
	
	

	Private Sub AddBodyHeader_File()  
		Dim roles$ 
		Dim role$ 

		If (0 = me.targetfilehandle_%) Then Error ERR_LOGTARGET_NOTOPEN, MSG_LOGTARGET_NOTOPEN

		Print #Me.targetfilehandle_%, |Program: |, | |, Me.ProgramName	
		Print #Me.targetfilehandle_%, |User: |, | |, Me.UserNameAbbrev
		Print #Me.targetfilehandle_%, |Server: |, | |, Me.Server
		Print #Me.targetfilehandle_%, |Db Title: |, | |, Me.dbTitle$ 
		Print #Me.targetfilehandle_%, |Db Filepath: |, Me.Filepath
		Print #Me.targetfilehandle_%, |Replica ID: |, | |, Me.dbRepID$
		Print #Me.targetfilehandle_%, |Notes Version: |, Me.myNotesVersion$
		Print #Me.targetfilehandle_%, |ACL Level: |, | |, getACLlevel(Me.acl)

		If IsArray(me.userRoles) Then
			ForAll s In me.userRoles 
				role$ = Trim(CStr(s)) 
				If Not isBlankString(role$) Then
					If isBlankString(roles$) Then
						roles$ = role$ 
					Else
						roles$ = roles$ & |, | & role$
					End If  
				End If 
			End ForAll 
		End If 
		
		If Not isBlankString(roles$) Then
			Print #Me.targetfilehandle_%, |ACL Roles: |, | |, roles$
		End If 

		Print #Me.targetfilehandle_%, | | 
		Print #Me.targetfilehandle_%, | | 
	End Sub
	
	
	
	

	Private Sub AddBodyHeader_NotesDocument()  

		Dim roles$ 
		Dim role$ 

		If (Me.TargetDocument Is Nothing) Then GoTo ExitPoint  

		If (Me.nrti_ Is Nothing) Then 
			If Me.ndoc_.HasItem(ITEMNAME_BODY) Then
				Set Me.nrti_ = Me.ndoc_.GetFirstItem(ITEMNAME_BODY)
			Else
				Set Me.nrti_ = New NotesRichTextItem(Me.ndoc_, ITEMNAME_BODY)
			End If 
		End If 

		Me.nrti_.AppendParagraphStyle nrtparastyle
		
		
		Me.nrti_.AppendStyle Me.nrtstyleTableHeaderLabel
		Me.nrti_.AppendText Me.progName$
		Me.nrti_.AddNewLine 2
		
		Me.nrti_.AppendStyle Me.nrtstyleTableHeaderLabel
		Me.nrti_.AppendText |LogID: |
		Me.nrti_.AddTab 2
		Me.nrti_.AppendStyle Me.nrtStyleTableHeader
		Me.nrti_.AppendText Me.ndoc_.Universalid
		Me.nrti_.AddNewLine 1
		
		Me.nrti_.AppendStyle Me.nrtstyleTableHeaderLabel
		Me.nrti_.AppendText |User: |
		Me.nrti_.AddTab 2
		Me.nrti_.AppendStyle Me.nrtStyleTableHeader
		Me.nrti_.AppendText Me.UserNameAbbrev
		Me.nrti_.AddNewLine 1

		Me.nrti_.AppendStyle Me.nrtstyleTableHeaderLabel
		Me.nrti_.AppendText |Server: |
		Me.nrti_.AddTab 2
		Me.nrti_.AppendStyle Me.nrtStyleTableHeader
		Me.nrti_.AppendText Me.dbServer$
		Me.nrti_.AddNewLine 1

		Me.nrti_.AppendStyle Me.nrtstyleTableHeaderLabel
		Me.nrti_.AppendText |Db Title: |
		Me.nrti_.AddTab 2
		Me.nrti_.AppendStyle Me.nrtStyleTableHeader
		Me.nrti_.AppendText Me.dbTitle$
		Me.nrti_.AddNewLine 1
		
		Me.nrti_.AppendStyle Me.nrtstyleTableHeaderLabel
		Me.nrti_.AppendText |Db Filepath: |
		Me.nrti_.AddTab 2
		Me.nrti_.AppendStyle Me.nrtStyleTableHeader
		Me.nrti_.AppendText Me.dbFilepath$
		Me.nrti_.AddNewLine 1
		
		Me.nrti_.AppendStyle Me.nrtstyleTableHeaderLabel
		Me.nrti_.AppendText |Replica ID: |
		Me.nrti_.AddTab 2
		Me.nrti_.AppendStyle Me.nrtStyleTableHeader
		Me.nrti_.AppendText Me.dbRepID$
		Me.nrti_.AddNewLine 1
		
		Me.nrti_.AppendStyle Me.nrtstyleTableHeaderLabel
		Me.nrti_.AppendText |Version: |
		Me.nrti_.AddTab 2
		Me.nrti_.AppendStyle Me.nrtStyleTableHeader
		Me.nrti_.AppendText Me.myNotesVersion$
		Me.nrti_.AddNewLine 1
		
		Me.nrti_.AppendStyle Me.nrtstyleTableHeaderLabel
		Me.nrti_.AppendText |ACL Level: |
		Me.nrti_.AddTab 2
		Me.nrti_.AppendStyle Me.nrtStyleTableHeader
		Me.nrti_.AppendText getACLlevel(Me.acl)
		Me.nrti_.AddNewLine 1


		If IsArray(me.userRoles) Then
			ForAll s In me.userRoles 
				role$ = Trim(CStr(s)) 
				If Not isBlankString(role$) Then
					If isBlankString(roles$) Then
						roles$ = role$ 
					Else
						roles$ = roles$ & |, | & role$
					End If  
				End If 
			End ForAll 
		End If 

		
		If isBlankString(roles$) Then
			Me.nrti_.AddNewLine 1
		Else  
			Me.nrti_.AppendStyle Me.nrtstyleTableHeaderLabel
			Me.nrti_.AppendText |ACL Roles|
			Me.nrti_.AddTab 1
			Me.nrti_.AppendStyle Me.nrtStyleTableHeader
			Me.nrti_.AppendText roles$ 
			Me.nrti_.AddNewLine 2
		End If 
		
	ExitPoint:
		Exit Sub 
	End Sub



	
	Private Sub setBody()
		Call Me.initializeRTStyles()

		If (Me.TargetDocument Is Nothing) Then GoTo ExitPoint  
		
		If Me.ndoc_.HasItem(ITEMNAME_BODY) Then
			Set Me.nrti_ = Me.ndoc_.GetFirstItem(ITEMNAME_BODY)
			Me.nrti_.AppendParagraphStyle nrtparastyle

		Else
			Set Me.nrti_ = New NotesRichTextItem(Me.ndoc_, ITEMNAME_BODY)
			
			If enhLogOutputToNotesLog Then Call Me.AddBodyHeader_NotesDocument()
			Me.nrti_.AppendParagraphStyle nrtparastyle

			If Not Me.isSpanningLogDocs Then
				Me.nrti_.AppendParagraphStyle nrtparastyle
				Me.nrti_.AppendStyle Me.nrtstyleMethodResult
				Me.nrti_.AppendText me.StartTimeStamp & | |
				Me.nrti_.AddTab 2 
				Me.nrti_.AppendText |LotusScript Started|
				Me.nrti_.AddNewLine 2 				
			End If 
		End If
		 
	ExitPoint:
		Exit Sub 
	End Sub 
	
	
	Private Sub SetXMLcontent()
		Call Me.initializeRTStyles()
		
		If (Me.TargetDocument Is Nothing) Then GoTo ExitPoint  
		
		If Me.ndoc_.HasItem(ITEMNAME_XMLCONTENT) Then
			Set Me.xmlnrti_ = Me.ndoc_.GetFirstItem(ITEMNAME_XMLCONTENT)
		Else
			Set Me.xmlnrti_ = New NotesRichTextItem(Me.ndoc_, ITEMNAME_XMLCONTENT)
			
			If (Not Me.isSpanningLogDocs) Then 	Me.xmlnrti_.AppendStyle Me.nrtstyleXMLcontent 
		End If 
		
	ExitPoint:
		Exit Sub 
	End Sub 
	
	
	Private Sub SetCachedError (code%, message$, errline&, methodname$, description$)
		Dim pos As Long		
		pos = Me.countCachedErrors + 1
		Me.cachedErrors(pos&).timestamp = CStr(Now)
		Me.cachedErrors(pos&).methodname$ = methodname$
		Me.cachedErrors(pos&).linenumber% = errline&
		Me.cachedErrors(pos&).code% = code%
		Me.cachedErrors(pos&).message$ = message$
		Me.cachedErrors(pos&).extended$ = description$
		Me.countCachedErrors = pos&
	End Sub 
	
	
	Private Sub SizeCheck()
		If (Me.isSpanningLogDocs _ 
		Or (Me.logType = LOGTYPE_FILE)) Then GoTo ExitPoint 
		
		If (Me.TargetDocument Is Nothing) Then GoTo ExitPoint  
		If (Me.ndoc_.Size <= LOG_DOC_MAX_SIZE) GoTo ExitPoint 
		
		Call Me.spanLogDocument(|Previous Log document exceeds maximum size.  |, _ 
		|Link to Previous Log document.  |, _ 
		|This log document exceeds maximum size.  |, _ 
		|Link to Next Log document.  |)
		
	ExitPoint:
		Exit Sub 
	End Sub 

	
	Private Function spanLogDocument(descripPrev$, commentPrev$, descripNext$, commentNext$) As Boolean
		Dim result As Boolean 
		On Error GoTo ErrorTrap
		
		Dim ndocTempOld As NotesDocument
		Dim ndocTempNew As NotesDocument 
		Dim ele As EnhancedLogEntry 
		
		If (Me.isSpanningLogDocs Or (Me.logType = LOGTYPE_FILE)) Then GoTo ExitPoint 
		
		Me.isSpanningLogDocs = True
		
		If (Me.logType = LOGTYPE_MAIL) Then  
			Call Me.logAction(descripNext$)
			Call Me.ChangeLogType(LOGTYPE_MAIL, ||, ||)
			Call Me.logAction(descripPrev$)

		Else
			Call Me.Save(False, False) 
			If (Me.TargetDocument Is Nothing) Then GoTo ExitPoint  
			
			Set ndocTempOld = Me.ndoc_
			Sleep(1) ' Forces a timestamp difference of 1 second between logs
			Call Me.createLogDoc()
			Me.nrti_.AddNewLine 1
			Set ele = New EnhancedLogEntry(LOGENTRY_TYPE_ACTION, descripPrev$, ||, ndocTempOld, commentPrev$, ||, 0, ||, 0, ||, Nothing)
			me.writeEntry_NotesDocument ele 
			Me.nrti_.AddNewLine 1
						
			Call Me.Save(False, False)
			
			Set ndocTempNew = Me.ndoc_
			Call Me.ResetDocument(ndocTempOld)
			Set Me.nrti_ = Me.ndoc_.getFirstItem(ITEMNAME_BODY)
			Me.nrti_.AddNewLine 1

			Set ele = New EnhancedLogEntry(LOGENTRY_TYPE_ACTION, descripNext$, ||, ndocTempNew, commentNext$, ||, 0, ||, 0, ||, Nothing)
			me.writeEntry_NotesDocument ele 
			
			Call Me.Save(False, False)
			
			Call Me.ResetDocument(ndocTempNew)
		End If 
		
		Me.isSpanningLogDocs = False
		result = True
		
	ExitPoint:
		spanLogDocument = result
		Exit Function
	ErrorTrap:
		On Error GoTo 0
		result = False
		Call Me.LogException(Err(), Error(), Erl(), GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||)
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then Resume ExitPoint Else Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
	End Function 

	
	Private Function resumeInternalError(caller$, extended$) As Boolean
		Dim extendedInfo As String
		Dim result As Boolean

		Dim currentError As ErrorInfo 		
		Dim callingmethod As String
		Dim msg As String
		Dim title As String

		Dim remaining As Integer
		
		On Error GoTo ErrorTrap

		currentError.timestamp = Format$(Now, FORMAT_TIMESTAMP) 
		currentError.message = Error$()
		currentError.code = Err() 
		currentError.linenumber = Erl() 
		currentError.methodname = CLASS_PREFIX & GetThreadInfo(LIB_LSI_THREAD_CALLPROC)
		currentError.callingmethod = caller$
		currentError.extended = extended$
		If (Me.internalErrorCount > 0) Then 
			ReDim Preserve Me.internalErrorStack(Me.internalErrorCount) As ErrorInfo 
		Else 
			ReDim Me.internalErrorStack(0) As ErrorInfo 
		End If
		
		Me.internalErrorStack(Me.internalErrorCount) = currentError 
		Me.internalErrorCount = me.internalErrorCount + 1 
	
		result = Me.ResumeOnLoggingFailure
		If (Not result) Then GoTo ExitPoint

		Me.countInternalErrors = Me.countInternalErrors + 1
		remaining% = MAX_RECOVER_ATTEMPTS - countInternalErrors
		If (remaining% < 0) Then remaining% = 0
		If Not isBlankString(extended$) Then extendedInfo$ = extended$ & Chr(10)
		extendedInfo$ = extendedInfo$ & |Recovery Attempts Remaining = | & CStr(remaining%)
		If (remaining = 0) Then Error ERR_INTERNAL_NORECOVER, MSG_INTERNAL_NORECOVER
		
		title$ = |Error | & CStr(currentError.code) & | at line: | & CStr(currentError.linenumber)
		msg$ = currentError.methodname & _ 
		Chr(10) & currentError.message & Chr(10) & _ 
		Chr(10) & |Calling Method: | & caller$ & _ 
		Chr(10) & extendedInfo$

		If getCurrentSession().IsOnServer Then 
			MessageBox title$ & Chr(10) & msg$
		Else
			msg$ = msg$ & Chr(10) & |Please notify your administrator.|
			MessageBox msg$, 16, TITLE	
		End If 

	ExitPoint:		
		resumeInternalError = result
		Exit Function
	ErrorTrap:
		On Error GoTo 0
		Me.ResumeOnLoggingFailure = False
		result = False
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, extendedinfo$
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If
	End Function 
	
	
	
	%REM
		Sub dumpBuffer
		Dumps the buffer contents to the appropriate ouput target and clears the buffer. 
	%END REM
	Private Sub dumpBuffer 
		On Error GoTo ErrorTrap
		
		Dim entry As EnhancedLogEntry 
		
		' BEGIN CODE 
		Set entry = me.buffer.FirstEntry 
		While Not (entry Is Nothing) 
			Me.writeEntry entry 
			Set entry = me.buffer.NextEntry 
		Wend
		Call me.buffer.Clear 
		
		If Me.AutoSave Then Me.Save False, False				
				
		
	ExitPoint: 
		Exit Sub 
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, ||
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If
	End Sub

	%REM
		Sub writeEntry_File
		Writes the entry to the Log File.  
		
		@param entry EnhancedLogEntry to be written to Log File.
	%END REM
	Sub writeEntry_File(entry As EnhancedLogEntry) 
		On Error GoTo ErrorTrap
		
		Dim linkTo As NotesLink
		Dim st As EnhancedLogStackTrace 
		Dim ste As StackTraceElement
		
		Dim temp$
		
		
		' BEGIN CODE 
		If (0 = Me.targetfilehandle_%) Then Call Me.OpenFileLog(||)
		
		Select Case entry.LogEntryType 
			Case LOGENTRY_TYPE_EXCEPTION: 
				temp$ = entry.ErrorMethod & | (Line | & CStr(entry.ErrorLine) & |)|
				If (Len(entry.ErrorMessage) > 0) Then temp$ = temp$ & entry.ErrorMessage 
				Print #Me.targetfilehandle_%, Format$(Now, FORMAT_TIMESTAMP) & |  | & entry.ErrorCode, temp$
				
				If Not isBlankString(entry.Message) Then Print #Me.targetfilehandle_%, | |, entry.Message 
				
			Case Else: 
				' LOGENTRY_TYPE_ACTION, LOG_ENTRY_TYPE_WARNING, LOGENTRY_TYPE_METHODRESULT, LOGENTRY_TYPE_EXTENDED
				If Not isBlankString(entry.Message) Then Print #Me.targetfilehandle_%, Format$(Now, FORMAT_TIMESTAMP) & |  | & entry.Message	
				
		End Select


		' EXTENDED CONTENT 
		If Not isBlankString(entry.ExtendedContent) Then Print #Me.targetfilehandle_%, | |, | |, entry.ExtendedContent 


		' LINK
		If entry.hasLink Then
			Set linkTo = entry.LinkTo 
			Print #Me.targetfilehandle_%, | |, | |, entry.LinkComment, linkTo.NotesURL
			Print #Me.targetfilehandle_%, | |
		End If 


		' STACK TRACE
		If Not (entry.StackTrace Is Nothing) Then 
			If Me.LogStackExceptions Then 
				If Me.LogStackExceptions Then
					Print #Me.targetfilehandle_%, |Method Stack:|
					Set st = entry.StackTrace 
					
					ForAll stackentry In st.Content 
						ste = stackentry 
						Print #Me.targetfilehandle_%, | | & Chr(9), ste.methodname & |()  Line #| & ste.linenumber & |  |
					End ForAll
				End If
			Else
				Print #Me.targetfilehandle_%, |Stack Logging is Disabled| 
			End If 					
		End If
		
	ExitPoint: 
		Exit Sub 
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, ||
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If
	End Sub
	
	
	%REM
		Sub writeEntry_Agent
		Writes the entry to the Agent Log.  
		
		@param entry EnhancedLogEntry to be written to NotesLog object.
	%END REM
	Sub writeEntry_Agent(entry As EnhancedLogEntry) 
		On Error GoTo ErrorTrap
		
		Dim linkTo As NotesLink
		Dim st As EnhancedLogStackTrace 
		Dim ste As StackTraceElement
		
		Dim temp$
		
		
		' BEGIN CODE 
		If (Me.nlog_ Is Nothing) Then Call Me.OpenAgentLog()
		Select Case entry.LogEntryType 
			Case LOGENTRY_TYPE_EXCEPTION: 
				temp$ = entry.ErrorMethod & | (Line | & CStr(entry.ErrorLine) & |)|
				If (Len(entry.ErrorMessage) > 0) Then temp$ = temp$ & entry.ErrorMessage 
				Me.nlog_.LogError entry.ErrorCode, temp$
				
				If entry.hasLink Then 
					Set linkTo = entry.LinkTo 
					Me.nlog_.LogAction entry.LinkComment & | | & linkTo.NotesURL 
				End If 
				
				If (Len(entry.Message) > 0) Then Me.nlog_.logAction entry.Message 
				
			Case Else: 
				' LOGENTRY_TYPE_ACTION, LOG_ENTRY_TYPE_WARNING, LOGENTRY_TYPE_METHODRESULT, LOGENTRY_TYPE_EXTENDED
				Me.nlog_.LogAction entry.Message	
				
				If entry.hasLink Then 
					Me.nrti_.AddTab 1
					Set linkTo = entry.LinkTo 
					Me.nlog_.LogAction entry.LinkComment & | | & linkTo.NotesURL 
				End If 
		End Select


		' EXTENDED CONTENT 
		If Not isBlankString(entry.ExtendedContent) Then Me.nlog_.LogAction entry.ExtendedContent 


		' STACK TRACE
		If Not (entry.StackTrace Is Nothing) Then 
			If Me.LogStackExceptions Then 
				If Me.LogStackExceptions Then
					Me.nlog_.LogAction |Method Stack:|
					Set st = entry.StackTrace 
					
					ForAll stackentry In st.Content 
						ste = stackentry 
						Me.nlog_.LogAction Chr(9) & ste.methodname & |()  Line #| & ste.linenumber & |  |
					End ForAll
				End If
			Else
				Me.nlog_.LogAction |Stack Logging is Disabled| 
			End If 					
		End If
		
	ExitPoint: 
		Exit Sub 
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, ||
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If
	End Sub
	
	
	%REM
		Sub writeEntry_NotesDocument
		Writes the entry to a NotesDocument
		
		@param entry EnhancedLogEntry to be written to a NotesDocument.
	%END REM
	Private Sub writeEntry_NotesDocument(entry As EnhancedLogEntry) 
		On Error GoTo ErrorTrap
		
		Dim nitm As NotesItem
		
		Dim linkTo As NotesLink
		Dim st As EnhancedLogStackTrace 
		Dim ste As StackTraceElement
		
		Dim writecount As Integer 
		
		Dim hasCode As Boolean 
		Dim hasMsg As Boolean 
		Dim hasLine As Boolean 
		Dim hasMethod As Boolean 
		
		
		
		' BEGIN CODE 
		If (Me.TargetDocument Is Nothing) Then GoTo ExitPoint  
		
		Call Me.SizeCheck()
		
		writecount = me.writecount_ + 1
		me.writecount_ = writecount 

		Select Case entry.LogEntryType 
			Case LOGENTRY_TYPE_EXCEPTION:
				If Not Me.hasLoggedException Then 
					Set nitm = Me.ndoc_.ReplaceItemValue(|A$LOGTYPE|, |Error|)
					nitm.IsSummary = True
					
					Set nitm = Me.ndoc_.ReplaceItemValue(ITEMNAME_HASERRORS, 1)
					nitm.IsSummary = True
				End If 
				
				' Set the error information items
				Set nitm = Me.ndoc_.ReplaceItemValue(|A$ERRCODE|, CStr(entry.ErrorCode))
				nitm.IsSummary = True
				
				Set nitm = Me.ndoc_.ReplaceItemValue(|A$ERRMSG|, entry.ErrorMessage)
				nitm.IsSummary = True
				
				Set nitm = Me.ndoc_.ReplaceItemValue(|A$description|, entry.Message)
				nitm.IsSummary = True
				
				hasCode = (entry.ErrorCode > 0)
				hasMsg = (Len(entry.ErrorMessage) > 0)
				hasLine = (entry.ErrorLine > 0)
				hasMethod = (Len(entry.ErrorMethod) > 0)
				
				Me.nrti_.AddNewLine 1 
				
				' Append the Error information to the RichTextItem
				If (hasCode Or hasMsg) Then Me.AddTimestamp nrtstyleTimestampError
				
				Me.nrti_.AppendStyle nrtstyleError
				
				If hasCode Then Me.nrti_.AppendText |Error | & CStr(entry.ErrorCode) & |: |			
				If hasMsg Then Me.nrti_.AppendText entry.ErrorMessage		
				
				If entry.hasLink Then 
					Me.nrti_.AddTab 1
					Set linkTo = entry.LinkTo 
					Call Me.AppendDocLink(linkTo.NotesObject, entry.LinkComment, entry.HotSpotText)
				End If 
				
				If (hasLine Or hasMethod) Then Me.nrti_.AddNewLine 1
				
				If (hasMethod) Then Me.nrti_.AppendText(entry.ErrorMethod & |();  |)
				If (hasLine) Then Me.nrti_.AppendText(|line | & CStr(entry.ErrorLine))
				
				Me.nrti_.AddNewLine 1
								
				If (Len(entry.Message) > 0) Then
					Me.nrti_.AppendStyle nrtstyleErrorExtended
					Me.nrti_.AppendText entry.Message
					Me.nrti_.AddNewLine 1
				End If 
				
				Me.hasLoggedException = True

				
			Case LOGENTRY_TYPE_WARNING: 
				If Not Me.hasLoggedWarning Then 
					Set nitm = Me.ndoc_.ReplaceItemValue(|A$ACTION|, entry.Message)
					nitm.IsSummary = True
					
					Set nitm = Me.ndoc_.ReplaceItemValue(ITEMNAME_HASWARNINGS, 1)
					nitm.IsSummary = True
					
					If Not Me.hasErrors Then 
						Set nitm = Me.ndoc_.ReplaceItemValue(|A$LOGTYPE|, |Warning|)
						nitm.IsSummary = True
					End If 
				End If 
				
				Me.AddTimestamp nrtstyleTimestampWarning
				Me.nrti_.AppendStyle nrtstyleWarning
				Me.nrti_.AppendText |Warning: | & entry.Message
				
				If entry.hasLink Then 
					Me.nrti_.AddTab 1
					Set linkTo = entry.LinkTo 
					Call Me.AppendDocLink(linkTo.NotesObject, entry.LinkComment, entry.HotSpotText)
				End If 
				
				Me.hasLoggedWarning = True
				
			Case LOGENTRY_TYPE_EXTENDED: 
				If Not Me.hasLoggedAction Then
					Set nitm = Me.ndoc_.ReplaceItemValue(|A$ACTION|, entry.Message)
					nitm.IsSummary = True
					
					If Not (Me.hasErrors Or Me.hasWarnings) Then 
						Set nitm = Me.ndoc_.ReplaceItemValue(|A$LOGTYPE|, |Action|)
						nitm.IsSummary = True
					End If 
				End If 

				If Not isBlankString(entry.Message) Then 					
					Me.AddTimestamp nrtstyleTimestampExtended
					Me.nrti_.AppendStyle nrtstyleExtendedContent
					Me.nrti_.AppendText entry.Message
					If Not isBlankString(entry.ExtendedContent) Then Me.nrti_.AddNewLine 1
				End If
				
				If entry.hasLink Then 
					Me.nrti_.AddTab 1
					Set linkTo = entry.LinkTo 
					Call Me.AppendDocLink(linkTo.NotesObject, entry.LinkComment, entry.HotSpotText)
				End If 
				
				Me.hasLoggedAction = True
				
			Case Else: 
				' LOGENTRY_TYPE_ACTION, LOGENTRY_TYPE_METHODRESULT
				If Not Me.hasLoggedAction Then
					Set nitm = Me.ndoc_.ReplaceItemValue(|A$ACTION|, entry.Message)
					nitm.IsSummary = True
					
					If Not Me.hasErrors Then 
						Set nitm = Me.ndoc_.ReplaceItemValue(|A$LOGTYPE|, |Action|)
						nitm.IsSummary = True
					End If 
				End If 

				Me.AddTimestamp nrtstyleTimestampNormal

				If (LOGENTRY_TYPE_METHODRESULT = entry.LogEntryType) Then 
					Me.nrti_.AppendStyle nrtstyleMethodResult
				Else 
					' assume LOGENTRY_TYPE_ACTION
					Me.nrti_.AppendStyle nrtstyleAction
				End If
				
				Me.nrti_.AppendText entry.Message
				If entry.hasLink Then 
					Me.nrti_.AddTab 1
					Set linkTo = entry.LinkTo 
					Call Me.AppendDocLink(linkTo.NotesObject, entry.LinkComment, entry.HotSpotText)
				End If 
				
				Me.hasLoggedAction = True
		End Select

		' EXTENDED CONTENT 
		If Not isBlankString(entry.ExtendedContent) Then
			Me.nrti_.AddTab 2
			Me.nrti_.AppendStyle nrtstyleExtendedContent
			Me.nrti_.AppendText entry.ExtendedContent
		End If 


		' STACK TRACE
		If Not (entry.StackTrace Is Nothing) Then 
			Me.nrti_.AppendStyle Me.nrtstyleErrorExtended 
			If Me.LogStackExceptions Then 
				Me.nrti_.AppendText |Method Stack:|
				Me.nrti_.AddNewLine 1 
				Me.nrti_.AppendStyle Me.nrtstyleErrorExtended 
				Set st = entry.StackTrace 
				
				ForAll stackentry In st.Content 
					ste = stackentry 
					Me.nrti_.AddTab 1	
					Me.nrti_.AppendText ste.methodname & |()  Line #| & ste.linenumber & |  |
					Me.nrti_.AddNewLine 1								
				End ForAll

				Me.nrti_.AddNewLine 1
			Else
				Me.nrti_.AppendText |Stack Logging is Disabled| 
				Me.nrti_.AddNewLine 2
			End If 					
		End If
		
		Me.nrti_.AddNewLine 1

	ExitPoint: 
		Exit Sub 
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, ||
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If
	End Sub
	
	
	%REM
		Sub writeEntry
		Writes the entry to the appropriate output target. 
		
		@param entry EnhancedLogEntry to be written to the output target.
	%END REM
	Private Sub writeEntry(entry As EnhancedLogEntry) 
		On Error GoTo ErrorTrap
		
		Dim message$ 
		Dim eventtype%
		Dim severity%
		

		' BEGIN CODE 
		If entry Is Nothing Then GoTo ExitPoint 
		
		Select Case Me.logType 
			Case LOGTYPE_NOTES, LOGTYPE_MAIL: 
				Me.writeEntry_NotesDocument entry 
				
			Case LOGTYPE_EVENT:
				Select Case entry.LogEntryType 
					Case LOGENTRY_TYPE_EXCEPTION:  
						severity% = 2 	' SEV_FAILURE
						eventtype% = 8 	' EV_ALARM 
						message$ = entry.ErrorMethod & |() Error | & CStr(entry.ErrorCode) & _ 
						| | & entry.ErrorMessage
						If Not isBlankString(entry.Message) Then message$ = message$ & |  | & entry.Message 
						If Not isBlankString(entry.ExtendedContent) Then message$ = message$ & |  | & entry.ExtendedContent 
						
					Case LOGENTRY_TYPE_WARNING: 
						severity% = 3 	' SEV_WARNING 
						eventtype% = 6 	' EV_MISC 
						message$ = entry.Message 
							
					Case Else: 
						severity% = 5 	' SEV_NORMAL
						eventtype% = 6 	' EV_MISC 
						message$ = entry.Message 
				End Select
				
				Call me.LogEvent(entry.Message, ||, eventtype%, severity%)					
				
			Case LOGTYPE_FILE: 
				Me.writeEntry_File entry 
				
			Case Else: 
				' LOGTYPE_AGENT
				Me.writeEntry_Agent entry 
				
		End Select
		
		If Me.LocalEcho Then 			
			If (Len(entry.ErrorMessage) > 0) Then Print entry.ErrorMessage 
			If (Len(entry.Message) > 0) Then Print entry.Message
			If (Len(entry.ExtendedContent) > 0) Then Print entry.ExtendedContent
		End If 
		
	ExitPoint: 
		Exit Sub 
	ErrorTrap:
		On Error GoTo 0
		If Me.resumeInternalError(GetThreadInfo(LIB_LSI_THREAD_CALLPROC), ||) Then 
			enhLogException CLASS_PREFIX, ||
			Resume ExitPoint 
		Else 
			Error Me.LastInternalErrorCode, Me.LastInternalErrorMessage
		End If
	End Sub
	
	
	
End Class 	



Public Class EnhancedLog 
	Private Property Get CLASS_PREFIX As String 
		CLASS_PREFIX = LIB_PREFIX & |EnhancedLog.|
	End Property

	Public Sub New (programName$)
		Call Me.Instantiate(programName$)
	End Sub 

	Public Sub Delete()
		Call Me.Close() 
	End Sub 
	
	Public Sub Close()
		If Not (singleton_ Is Nothing) Then 
			Delete singleton_
			Set singleton_ = Nothing
		End If 
	End Sub 
	
	Public Function AppendAsDocLink (source As NotesDocument, fieldname$, linkcomment$, hotspottext$) As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		AppendAsDocLink = singleton_.AppendAsDocLink (source, fieldname$, linkcomment$, hotspottext$)
	End Function 

	Public Sub ClearCachedError()
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)	
		Call singleton_.ClearCachedError()
	End Sub 

	Public Sub LogAction (description$)
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogAction description$
	End Sub 
	
	Public Sub LogActionWithLink (description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$)
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogActionWithLink description$, linkTo, linkcomment$, HotSpotText$
	End Sub 
	

	Public Sub LogError (code%, description$)
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogError code%, description$
	End Sub 
	

	Public Sub LogEvent (message$, queuename$, eventType%, severity%)
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogEvent message$, queuename$, eventType%, severity%
	End Sub 
	
	
	Public Sub LogException (code%, errMsg$, errline&, methodname$, description$)
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogException code%, errMsg$, errline&, methodname$, description$
	End Sub 
	
	
	Public Sub LogExceptionWithLink (code%, errMsg$, errline&, methodname$, description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$) 
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogExceptionWithLink code%, errMsg$, errline&, methodname$, description$, linkTo, linkcomment$, HotSpotText$
	End Sub 
	
	Public Sub LogExtendedContent (description$, extendedcontent$)
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogExtendedContent description$, extendedcontent$
	End Sub 
	
	Public Sub LogExtendedContentWithLink (description$, extendedcontent$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$)
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogExtendedContentWithLink description$, extendedcontent$, linkTo, linkcomment$, HotSpotText$
	End Sub 
	
	Public Sub LogMethodResult (description$)
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogMethodResult description$
	End Sub 		

	
	Public Sub LogMethodResultWithLink (description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$)
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogMethodResultWithLink description$, linkTo, linkcomment$, HotSpotText$
	End Sub 
	
	
	Public Sub LogStackTrace()
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogStackTrace
	End Sub 
	
	
	Public Sub LogWarning (description$)
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogWarning description$
	End Sub 
	
	
	Public Sub LogWarningWithLink (description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$)
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogWarningWithLink description$, linkTo, linkcomment$, HotSpotText$
	End Sub 
	
	
	Public Function OpenAgentLog() As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		OpenAgentLog = singleton_.OpenAgentLog()
	End Function 
	
	
	Public Function OpenFileLog (path$) As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		OpenFileLog = singleton_.OpenFileLog(path$)
	End Function 
	
	
	Public Function OpenMailLog (recipients As Variant, subject$) As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		OpenMailLog = singleton_.OpenMailLog(recipients, subject$)
	End Function 
	
	Public Function OpenNotesLog (server$, dbfile$) As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		OpenNotesLog = singleton_.OpenNotesLog(server$, dbfile$)
	End Function 
	
	Public Function Save (force As Boolean, createResponse As Boolean) As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		Save = singleton_.Save(force, createResponse)
	End Function 
	
	Public Property Get ActionsIncludeMethodNames As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		ActionsIncludeMethodNames = singleton_.ActionsIncludeMethodNames
	End Property 
	
	Public Property Get AutoSave As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		AutoSave = singleton_.AutoSave
	End Property 
	
	Public Property Get CachedErrorCode As Integer
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		CachedErrorCode = singleton_.CachedErrorCode
	End Property 
	
	Public Property Get CachedErrorExtended As String
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		CachedErrorExtended = singleton_.CachedErrorExtended
	End Property 
	
	Public Property Get CachedErrorLine As Integer
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		CachedErrorLine = singleton_.CachedErrorLine
	End Property 
	
	Public Property Get CachedErrorMessage As String
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		CachedErrorMessage = singleton_.CachedErrorMessage
	End Property 
	
	Public Property Get CachedErrorMethod As String
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		CachedErrorMethod = singleton_.CachedErrorMethod
	End Property 
	
	Public Property Get CachedErrorTimestamp As String
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		CachedErrorTimestamp = singleton_.CachedErrorTimestamp
	End Property 
	
	Public Property Get TargetDatabase As NotesDatabase
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		Set TargetDatabase = singleton_.TargetDatabase
	End Property 
	
	Public Property Get Filepath As String
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		Filepath = singleton_.Filepath$
	End Property 
	
	Public Property Get hasActions As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		hasActions = singleton_.hasActions
	End Property 
	
	Public Property Get hasCachedError As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		hasCachedError = singleton_.hasCachedError
	End Property 
	
	Public Property Get hasEntries As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		hasEntries = singleton_.hasEntries
	End Property 
	
	Public Property Get hasErrors As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		hasErrors = singleton_.hasErrors
	End Property 
	
	Public Property Get LocalEcho As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		LocalEcho = singleton_.LocalEcho	
	End Property 
	
	Public Property Get LogActions As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		LogActions = singleton_.LogActions		
	End Property 
	
	Public Property Get LogErrors As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		LogErrors = singleton_.LogErrors
	End Property 
	
	Public Property Get LogMethodResults As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		LogMethodResults = singleton_.LogMethodResults
	End Property 
	
	Public Property Get LogOutputToNotesLog As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		LogOutputToNotesLog = singleton_.LogOutputToNotesLog
	End Property 
	
	Public Property Get LogStackExceptions As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		LogStackExceptions = singleton_.LogStackExceptions
	End Property 
	
	Public Property Get LogWarnings As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		LogWarnings = singleton_.LogWarnings		
	End Property 
	
	Public Property Get NumActions As Long
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		NumActions = singleton_.NumActions
	End Property 
	
	Public Property Get NumErrors As Long
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		NumErrors = singleton_.NumErrors
	End Property 
	
	Public Property Get OverwriteFile As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		OverwriteFile = singleton_.OverwriteFile
	End Property 
	
	Public Property Get Parent As NotesSession
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		Set Parent = singleton_.Parent
	End Property 
	
	Public Property Get ProgramName As String
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		ProgramName = singleton_.ProgramName
	End Property 
	
	Public Property Get ResumeOnLoggingFailure As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		ResumeOnLoggingFailure = singleton_.ResumeOnLoggingFailure
	End Property 
	
	Public Property Get SendTo As Variant
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		SendTo = singleton_.SendTo
	End Property 
	
	Public Property Get Server As String
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		Server = singleton_.Server
	End Property 
	
	Public Property Get Subject As String
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		Subject = singleton_.Subject
	End Property 
	
	Public Property Get UserName As NotesName
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		Set UserName = singleton_.UserName
	End Property 
	
	Public Property Get UserNameAbbrev As String
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		UserNameAbbrev = singleton_.UserNameAbbrev
	End Property 
	
	Public Property Set ActionsIncludeMethodNames As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.ActionsIncludeMethodNames = ActionsIncludeMethodNames
	End Property 
	
	Public Property Set AutoSave As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.AutoSave = AutoSave	
	End Property 
	
	Public Property Set LocalEcho As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LocalEcho = LocalEcho
	End Property 
	
	Public Property Set LogActions As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogActions = LogActions	
	End Property 
	
	Public Property Set LogErrors As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogErrors = LogErrors	
	End Property 
	
	Public Property Set LogMethodResults As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogMethodResults = LogMethodResults	
	End Property 
	
	Public Property Set LogOutputToNotesLog As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogOutputToNotesLog = LogOutputToNotesLog	
	End Property 
	
	Public Property Set LogStackExceptions As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogStackExceptions = LogStackExceptions	
	End Property 
	
	Public Property Set LogWarnings As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.LogWarnings = LogWarnings	
	End Property 

	Public Property Set OverwriteFile As Boolean

		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.OverwriteFile = OverwriteFile	
	End Property 
	
	Public Property Set ProgramName As String
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.ProgramName = ProgramName
	End Property  
	
	Public Property Set ResumeOnLoggingFailure As Boolean
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.ResumeOnLoggingFailure = ResumeOnLoggingFailure	
	End Property 
	
	Public Property Set SendTo As Variant
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.SendTo = SendTo
	End Property 	
	
	Public Property Set Subject As String
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.Subject = Subject
	End Property 
	
	Public Property Set UserName As NotesName
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		Set singleton_.UserName = UserName
	End Property 
	
	Public Property Set UserNameAbbrev As String
		If (singleton_ Is Nothing) Then Call Me.Instantiate(||)
		singleton_.UserNameAbbrev = UserNameAbbrev
	End Property 
	
	Private Sub Instantiate (programname$)
		Dim extendedInfo As String
		Dim errcode As Integer
		Dim errmsg As String
		On Error GoTo ErrorTrap
		
		errcode% = 0
		extendedInfo$ = |Program Name: | & programname$
		
		If (singleton_ Is Nothing) Then Set singleton_ = New Singleton(programname$)
		
	ExitPoint:
		If (errcode% <> 0) Then Error errcode%, errmsg$
		Exit Sub
	ErrorTrap:
		On Error GoTo 0
		errcode% = Err()
		errmsg$ = Error()
		enhLogException CLASS_PREFIX, extendedInfo$
		Resume ExitPoint		
	End Sub 
End Class 	
'++LotusScript Development Environment:2:2:Initialize:4:10



Sub Initialize
	' No code allowed here if class library is to be used by a web service.
End Sub 

'++LotusScript Development Environment:2:2:Terminate:2:10

Sub Terminate	
	If (Not enhLog_ Is Nothing) Then
		If enhLog_.hasEntries Then enhLog_.Save False, False
		Delete enhLog_
		Set enhLog_ = Nothing
	End If 
	
End Sub 

'++LotusScript Development Environment:2:1:enhLogGetLogConfigText:10:8

%REM
	Function enhLogGetLogConfigText
	Gets the text representation of the Log Config value for the specified Item name.

	@param itemname$ String Name of the NotesItem value to retrieve.
	@return Text for the specified item name.  Returns empty string ("") if document or item not found.
	
%END REM
Public Function enhLogGetLogConfigText(itemname$) As String
	Dim extendedInfo As String
	Dim result As String
	On Error GoTo ErrorTrap
	
	extendedInfo$ = |Item Name: | & itemname$
	result = getDocItemText(enhLogGetLogConfigDoc(False), itemname$)
	
	ExitPoint:
	enhLogGetLogConfigText = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	result = ||
	Resume ExitPoint	
End Function  

'++LotusScript Development Environment:2:1:enhLogArchiveDocuments:2:8

Public Function enhLogArchiveDocuments (server$, filepath$, view$, max&, purge As Boolean, archived&, purged&) As Boolean
	Dim extendedInfo As String
	Dim result As Boolean
	On Error GoTo ErrorTrap
	
	
	Const ITEMNAME_SOURCEUNID = |SourceDocUNID|
	
	Dim ndbSource As NotesDatabase
	Dim nvwSource As NotesView
	
	Dim ndbTarget As NotesDatabase
	Dim nvnav As NotesViewNavigator
	Dim nvent As NotesViewEntry
	Dim ndocSource As NotesDocument
	Dim ndocTarget As NotesDocument
	Dim ncolPurge As NotesDocumentCollection
	Dim nitm As NotesItem
	Dim lstrArchivedSubjects List As String
	Dim strUNIDsource As String
	Dim numToPurge As Long
	Dim subjectsExist As Boolean
	

	extendedInfo$ = |TARGET SERVER: | & server$ & _ 
	Chr(10) & |TARGET FILEPATH: | & filepath$ & _ 
	Chr(10) & |SOURCE SOURCE VIEWNAME: | & view$ & _ 
	Chr(10) & |MAXDOCS: | & CStr(max&) & _ 
	Chr(10) & |PURGE AFTER ARCHIVE: | & CStr(purge)
	
	enhLogAction LIB_PREFIX, extendedInfo$
	
	subjectsExist = False
	result = False
	archived& = 0
	purged& = 0 
	
	Set ndbTarget = getOpenDatabase(server$, filepath$)
	If (ndbTarget Is Nothing) Then GoTo ExitPoint
	
	Set ndbSource = getCurrentDb()
	If (ndbSource Is Nothing) Then GoTo ExitPoint
	extendedInfo$ = extendedInfo$ & _ 
	Chr(10) & |SOURCE SERVER: | & ndbSource.Server & _ 
	Chr(10) & |SOURCE FILEPATH: | & ndbSource.Filepath

	Set nvwSource = ndbSource.GetView(view$)
	If (nvwSource Is Nothing) Then Error ERR_VIEW_NOT_FOUND, MSG_VIEW_NOT_FOUND
	
	Set nvnav = nvwSource.CreateViewNav
	If (nvnav.Count < 1) Then 
		enhLogAction LIB_PREFIX, |No Documents to Archive|
		GoTo ExitPoint 	' no documents to archive
	End If 
	
	If purge Then Set ncolPurge = getEmptyDocumentCollection(ndbSource)
	
	' iterate through the source documents, copy them to the target database
	Set nvent = nvnav.GetFirstDocument
	
	If (nvent Is Nothing) Then GoTo ExitPoint
	
	Do While Not (nvent Is Nothing) 
		Set ndocSource = nvent.Document
		Set ndocTarget = ndocSource.CopyToDatabase(ndbTarget)
		
		If (ndocTarget Is Nothing) Then GoTo ExitPoint 	' the copy failed.
		
		' Store the source UNID on the target document
		strUNIDsource = ndocSource.UniversalID
		If ndocTarget.HasItem(ITEMNAME_SOURCEUNID) Then
			Set nitm = ndocTarget.GetFirstItem(ITEMNAME_SOURCEUNID)
			Call nitm.AppendToTextList(strUNIDsource)
		Else
			Set nitm = ndocTarget.ReplaceItemValue(ITEMNAME_SOURCEUNID, strUNIDsource) 
		End If 
		
		nitm.IsSummary = True
		If (Not ndocTarget.Save(False, False)) Then GoTo ExitPoint ' the update failed
		If ndocSource.HasItem(|Subject|) Then
			lstrArchivedSubjects(ndocSource.NoteID) = Trim$(ndocSource.getFirstItem(|Subject|).Text)
			subjectsExist = True
		End If 
		
		enhLogAction ||, |Archived | & ndocSource.UniversalID & | to | & ndocTarget.UniversalID
		archived& = archived& + 1
		
		If purge Then ncolPurge.AddDocument ndocSource
		
		Set nvent = nvnav.GetNextDocument(nvent)
		If ((Not (nvent Is Nothing)) And (archived => max&)) Then
			result = True
			enhLogAction LIB_PREFIX, |Additional documents result unarchived.|
			Exit Do
		End If 
	Loop
	
PURGE:
	%REM 	
	 	Purge the documents but don't force the removal.
		It is possible for log documents which are still being written to be picked up by the archive process.  
		If removal is forced the these logs will be lost.
	%END REM
	If purge Then 
		enhLogAction ||, |Purging | & CStr(ncolPurge.Count) & | documents.|
		numToPurge& = ncolPurge.Count
		ncolPurge.RemoveAll (False) 
		
		' get the correct count in the event that some docs were not purged
		purged& = numToPurge& - ncolPurge.Count
	End If 
	
	If subjectsExist Then
		enhLogExtendedContent ||, |Archived Subjects:|, |[NoteID]: Subject|
		ForAll strSubject In lstrArchivedSubjects
			enhLogExtendedContent ||, ||, ListTag(strSubject) & |: | & strSubject
		End ForAll 
	End If 
	
	' if here then the archive (and purge if requested) worked.
	If result Then 
		Call getEnhLog()
		Call enhLog_.Save(False, False)
	End If 
	
ExitPoint:
	On Error GoTo 0
	enhLogArchiveDocuments = result
	enhLogMethodResult LIB_PREFIX, |Archived | & Format$(archived&, FORMAT_WHOLE_THOUSANDS) & | documents.|
	enhLogMethodResult LIB_PREFIX, |Purged | & Format$(purged&, FORMAT_WHOLE_THOUSANDS) & | documents.|
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:enhLogProfileMethodFinish:12:8

%REM
	Function enhLogProfileMethodFinish
	Appends the clock ticks for a specified method to the global profile list.
	
	@param classname$: Class for calling Method.
	@param operation$: Identifies "GET" or "SET" operation of calling properties.
	
		
	@return Number of clock ticks since enhLogProfileMethodStart() for the method was called.
%END REM
Public Function enhLogProfileMethodFinish(ByVal classname$, ByVal operation$) As Double 
	Dim target As ProfiledMethod

	Dim extendedInfo As String
	Dim result As Double


	Dim chunks(3) As String 
	Dim tag As String
	Dim c_method As String 
	Dim c_module As String
	Dim errTag As String  
	Dim ticks As Double 

	On Error GoTo ErrorTrap
	
	
	If enhLogIsProfilingEnabled() Then
		TrimString classname$ 
		operation$ = UCase$(Trim$(operation$))
		c_module$ = GetThreadInfo(LIB_LSI_THREAD_CALLMODULE)
		c_method$ = GetThreadInfo(LIB_LSI_THREAD_CALLPROC)	
		chunks(0) = c_module$
		chunks(1) = classname$
		chunks(2) = c_method$
		chunks(3) = operation$
		tag$ = UCase$(Join(FullTrim(chunks), DEFAULT_DELIMITER))
		extendedInfo$ = |Tag: | & tag$
		
		Set target = genhl_ProfiledMethods.getValue(tag$) 
		If (target Is Nothing) Then 
			Set target = New ProfiledMethod(c_module$, classname$, c_method$, operation$, GetThreadInfo(LIB_LSI_THREAD_TICKS))
			Set genhl_ProfiledMethods.content(tag$) = target 
			Error ERR_OPERATION_FAILED, MSG_OPERATION_FAILED
		End If
		
		target.Operation = operation$
		ticks# = GetThreadInfo(LIB_LSI_THREAD_TICKS)
		target.elapsed = target.elapsed + (ticks# - target.ticks) 
		target.Ticks = ticks#	
		If target.isStarted Then		
			If (target.RecursionDepth > 0) Then target.RecursionDepth = target.RecursionDepth - 1
			target.isStarted = (target.Recursions > 0)
		End If  
		Set genhl_ProfiledMethods.content(tag$) = target 
	End If 
	
ExitPoint:
	enhLogProfileMethodFinish = result#
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	If (Err() = ERR_OPERATION_FAILED) Then
		
		enhLogExtendedContent LIB_PREFIX, ||, |Profiled Methods| 
		ForAll element In genhl_ProfiledMethods.content 
			tag$ = ListTag(element)
			enhLogExtendedContent ||, ||, |[| & tag$ & |]|
			enhLogExtendedContent ||, ||, |Module: | & element.modulename
			enhLogExtendedContent ||, ||, |Class: | & element.classname 
			enhLogExtendedContent ||, ||, |Method: | & element.methodname 
			enhLogExtendedContent ||, ||, |Operation: | & element.operation 
			enhLogExtendedContent ||, ||, |Elapsed: | & CStr(element.elapsed)
			enhLogExtendedContent ||, ||, |Ticks: | & CStr(element.ticks)
			enhLogExtendedContent ||, ||, |Calls: | & CStr(element.calls)
			If (element.recursions > 0) Then 
				enhLogExtendedContent ||, ||, |Recursions: | & CStr(element.recursions)
				enhLogExtendedContent ||, ||, |Max Recursion Depth: | & CStr(element.maxrecursiondepth)
			End If 

			If (tag$ = errTag$) Then 
				enhLogExtendedContent ||, ||, |Is Started: FALSE|	
			Else
				enhLogExtendedContent ||, ||, |Is Started: | & CStr(element.isStarted)	
			End If 
			
			enhLogExtendedContent ||, ||, || 
		End ForAll 
	End If 
	
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:stripHTML:11:8

%REM THIS METHOD INTENTIONALLY HAS NO ERROR TRAPPING  
	Function stripHTML 
	Replaces all html tags from a string
	
	@param source$  String within which to search 
	@param stripOrphans flag indicating if Orphan HTML tags should also be stripped
	
	@return source with all html tags stripped out
%END REM ERRORS MUST BE HANDLED BY CALLING CODE
Public Function stripHTML (source$, stripOrphans As Boolean) As String
	Dim intPosOpen As Integer
	Dim intPosClose As Integer
	Dim strTarget As String
	
	strTarget$ = source$
	
	If stripOrphans Then
		' Strip out Orphan Tags
		Do
			intPosOpen% = InStr(strTarget$, |<|)
			intPosClose% = InStr(strTarget$, |>|)
			
			If intPosOpen% < intPosClose% Then
				' Either the first open indicator occurs prior to the first close indicator,
				' or doesn't exist at all.
				If intPosOpen% = 0 Then
					' The first open indicator doesn't exist.
					' If the Orphan close indicator exists, then strip it out.
					
					If (intPosClose% > 0) Then strTarget$ = stripFirstSubstr(strTarget$, |>|)
				Else
					' The first open indicator exists, and occurs prior to the first close indicator.
					' THIS INDICATES STANDARD MARKUP. STRIP IT OUT
					
					strTarget$ = stripFirstSubstr(strTarget$, Mid$(strTarget$, intPosOpen%, _ 
					(intPosClose% - intPosOpen%) + 1))
				End If ' intPosOpen% = 0
			Else
				' Either the first close indicator occurs prior to the first open indicator,
				' or doesn't exist at all.
				If intPosClose% = 0 Then
					' The first close indicator doesn't exist.
					' If the Orphan open indicator exists, then strip it out.
					
					If (intPosOpen% > 0) Then strTarget$ = stripFirstSubstr(strTarget$, |<|)
				Else
					' The first close indicator occurs prior to the first open indicator,
					' and is therefore an Orphan. Strip it out.
					
					strTarget$ = stripFirstSubstr(strTarget$, |>|)
				End If 
			End If 
		Loop While ((intPosOpen% + intPosClose%) > 0)
		
	Else
		' Orphan tags are to be ignored.
		
		Do
			intPosOpen% = InStr(strTarget$, |<|)
			If intPosOpen% > 0 Then
				' An open indicator exists. Find the subsequent close indicator
				intPosClose% = InStr(intPosOpen, strTarget$, |>|)
			Else
				' No open indicator exists. Set the close position to zero and bail out.
				intPosClose% = 0
			End If 
			
			If intPosClose% > intPosOpen% Then
				' The first open indicator exists, and occurs prior to the first close indicator.
				' THIS INDICATES STANDARD MARKUP. STRIP IT OUT
				strTarget$ = stripFirstSubstr(strTarget$, Mid$(strTarget$, intPosOpen%, _ 
				(intPosClose% - intPosOpen%) + 1))
			Else
				' No close indicator exists. Set the open position to zero and bail out.
				intPosOpen% = 0
			End If 
		Loop While ((intPosOpen% + intPosClose%) > 0)		
	End If 
	
	stripHTML$ = strTarget$	
End Function 

'++LotusScript Development Environment:2:1:getServerFilepath:2:8

Private Function getServerFilepath (ByVal server$, ByVal filepath$) As String
	TrimString server$
	TrimString filepath$
	
	If (Len(server$) > 0) Then
		getServerFilepath = server$ & |!!| & filepath$
	Else
		getServerFilepath = filepath$
	End If 
End Function 

'++LotusScript Development Environment:2:2:enhLogCloseLog:5:8
%REM
	Sub enhLogCloseLog
	Closes the log
%END REM
Public Sub enhLogCloseLog() 
	If Not (enhLog_ Is Nothing) Then
		If enhLog_.hasEntries Then enhLog_.Save False, False
		Delete enhLog_
		Set enhLog_ = Nothing
	End If 
End Sub

'++LotusScript Development Environment:2:2:InstantiateLoggingSession:2:8

Private Sub InstantiateLoggingSession()
	lstrLogTypes(LOGTYPE_NOTES) = |NotesLog|
	lstrLogTypes(LOGTYPE_AGENT) = |AgentLog|
	lstrLogTypes(LOGTYPE_FILE) = |FileLog|
	lstrLogTypes(LOGTYPE_MAIL) = |MailLog|
End Sub 

'++LotusScript Development Environment:2:2:enhLogSetLogWarnings:2:8

Public Sub enhLogSetLogWarnings (source As Boolean)
	Call getEnhLog()
	enhLog_.LogWarnings = source
End Sub 

'++LotusScript Development Environment:2:2:enhLogSetUserNameAbbrev:2:8

Public Sub enhLogSetUserNameAbbrev (source$)
	Call getEnhLog()
	enhLog_.UserNameAbbrev = source
End Sub

 

'++LotusScript Development Environment:2:1:uiSelectDatabase:11:8
%REM
	Function uiSelectDatabase
	Description: Presents the user with a dialog box from which to select a database, 
		then updates the appropriate fields on the current UIdocument. 
		
	@param title$ Title for the prompt
	@param msg$ Message for the prompt
	@param fieldnameServer$ Fieldname for the server field to be set
	@param fieldnameFilepath$ Fieldname for the filepath field to be set
%END REM
Public Function uiSelectDatabase(title$, msg$, fieldnameServer$, fieldnameFilepath$) As NotesDatabase 
	
	Dim extendedInfo As String
	On Error GoTo ErrorTrap
	
	Dim result As NotesDatabase 
	Dim nuiwsp As New NotesUIWorkspace()
	Dim nuidoc As NotesUIDocument
	Dim ndb As NotesDatabase
	Dim selection As Variant
	
	Dim server As String
	Dim filepath As String
	Dim errors As Integer
	Dim updated As Boolean 
	
	Set nuidoc = nuiwsp.CurrentDocument
	
Prompt:
	On Error GoTo ErrorTrap
	selection = nuiwsp.Prompt(13, title$, msg$)
	If Not IsArray(selection) Then GoTo ExitPoint
	
	extendedInfo$ = |Database = | & Join(selection, |   |)
	server$ = selection(0)
	filepath$ = selection(1)
	
	Set ndb = New NotesDatabase(server$, filepath$)
	If Not ndb.IsOpen Then Call ndb.Open(ndb.Server, ndb.FilePath)
	If Not ndb.IsOpen Then Error ERR_DATABASE_NOTOPEN, MSG_DATABASE_NOTOPEN
	
	If Not isBlankString(fieldnameServer$) Then 
		Call nuidoc.FieldSetText(fieldnameServer$, server$)
		updated = True
	End If 
	
	If Not isBlankString(fieldnameFilepath$) Then 
		Call nuidoc.FieldSetText(fieldnameFilepath$, filepath$)
		updated = True
	End If 
	
	If updated Then Call nuidoc.Refresh()
	
ExitPoint:
	Set uiSelectDatabase = result
	Exit Function
ErrorTrap:
	On Error GoTo 0 
	Set result = Nothing 
	enhLogException LIB_PREFIX, extendedInfo$
	MessageBox Error(), 16, |Error | & CStr(Err())
	errors% = errors% + 1
	If (errors% > 5) Then Resume ExitPoint
	Resume Prompt
End Function

'++LotusScript Development Environment:2:2:enhLogReleaseVersionBuild:6:8

%REM
	Sub enhLogReleaseVersionBuild
	Writes the Enhanced Log Release, Version, and Build number to the log. 
%END REM
Public Sub enhLogReleaseVersionBuild() 
	enhLogExtendedContent ||, ||, _ 
	|Enhanced Log, | & RELEASE_DATE _ 
	& |, Version: | & VERSION _ 
	& |, Build: | & BUILD
End Sub

'++LotusScript Development Environment:2:1:strEndsWith:11:8


%REM
	Function strEndsWith
	Indicates if a String ends with another String 
	
	@param searchin$ The string to check for ending with searchfor$
	@param searchfor$ The string with searchin$ needs to end with
	@return Flag indicating if searchin$ ends with searchfor$
%END REM
Public Function strEndsWith(searchin$, searchfor$) As Boolean 
	On Error GoTo ErrorTrap
	
	' exception variables
	Dim extendedinfo List As String 
	Dim msg$

	Dim result As Boolean
	
	extendedinfo(|searchin|) = searchin$
	extendedinfo(|searchfor|) = searchfor$
	
	result = (0 = StrComp(searchfor$, Mid(searchin$, Len(searchin$) - (Len(searchfor$) - 1)), 5))
	
ExitPoint: 
	strEndsWith = result
	Exit Function 
ErrorTrap:
	On Error GoTo 0
	ForAll s In extendedinfo
		If isBlankString(msg$) Then 
			msg$ = ListTag(s) & |: | & s
		Else 
			msg$ = msg$ & Chr(10) & ListTag(s) & |: | & s
		End If
	End ForAll
	enhLogException LIB_PREFIX, msg$
	Resume ExitPoint
End Function

'++LotusScript Development Environment:2:1:enhLogStackTrace:2:8

Public Function enhLogStackTrace(prefix$, description$) As Boolean
	Dim result As Boolean	
	On Error GoTo ErrorTrap

	Dim msg As String 
	result = True	
	
	If (Len(description$) > 0) Then 
		msg$ = prefix$ & Chr(10) & description$
	ElseIf (Len(prefix$) = 0) Then 
		msg$ = GetThreadInfo(LIB_LSI_THREAD_CALLMODULE) & |.| & GetThreadInfo(LIB_LSI_THREAD_CALLPROC)	
	Else
		msg$ = prefix$
	End If 

	
	Call getEnhLog()
	enhLog_.logWarning msg$
	enhLog_.logStackTrace
	
ExitPoint:	
	enhLogStackTrace = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, description$
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:2:enhLogSetActionsIncludeMethodNames:2:8

Public Sub enhLogSetActionsIncludeMethodNames (source As Boolean)
	Call getEnhLog()
	enhLog_.ActionsIncludeMethodNames = source
End Sub 

'++LotusScript Development Environment:2:1:getScalar:3:8


Private Function getScalar(source As Variant) As Variant	
	Dim result As Variant
	
	On Error GoTo ErrorTrap
	
	If IsScalar(source) Then
		If IsObject(source) Then
			Set result = source
		Else
			result = source
		End If 
	Else
		If IsObject(source(LBound(source))) Then
			Set result = source(LBound(source))
		Else
			result = source(LBound(source))
		End If 
	End If 
	
ExitPoint:
	If IsObject(result) Then
		Set getScalar = result
	Else
		getScalar = result
	End If 
	Exit Function
ErrorTrap:
	On Error GoTo 0 
	If Not (enhLog_ Is Nothing) Then enhLogException LIB_PREFIX, ||
	result = False
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:4:enhLogOutputToNotesLog Set:8:8



%REM
	Property Set enhLogOutputToNotesLog
	Specifies if log activity should be recorded using the Events form in the Notes Log (log.nsf by default) 
%END REM
Public Property Set enhLogOutputToNotesLog As Boolean 
	Call getEnhLog()

	enhLog_.LogOutputToNotesLog = enhLogOutputToNotesLog
	
	' enhLog_.OpenNotesLog getCurrentDb().Server, |log.nsf|	
	' **********
	' DSO - 20210707 
	' Above line of code replaced to satisify correct default of logging to the server (or client) that the code is RUNNING ON, 
	' rather than the server (or client) that the NSF exists on. 
	' **********

	If enhLog_.LogOutputToNotesLog Then enhLog_.OpenNotesLog ||, |log.nsf|	
End Property

'++LotusScript Development Environment:2:1:enhLogExceptionWithLink:16:8

%REM 
	Function enhLogExceptionWithLink
	
	Writes information about an Exception to the log if LogExceptions is enabled. 
	Appends a NotesLink to a NotesObject (Database, Document, or View) to the logged Exception. 
	
	@param prefix$ Prefix information 
	@param description$ information to be written to the log. 
	@param linkTo Object for which to include a NotesLink in the log
	@param linkcomment$ Comment for the link
	@param HotSpotText$ HotSpotText for the link
	
	@return Flag indicating if information about the Exception was written to the log. 
%END REM
Public Function enhLogExceptionWithLink (prefix$, description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$) As Boolean
	Dim result As Boolean	
	On Error GoTo ErrorTrap
	
	Dim errcode As Integer
	Dim errline As Long
	Dim errmsg As String
	Dim methodname As String

	errcode% = Err()
	errline& = Erl()
	errmsg$ = Error()
	methodname$ = prefix$ & GetThreadInfo(LIB_LSI_THREAD_CALLPROC)

	Call getEnhLog()		  
	If Not enhLog_.LogErrors Then GoTo ExitPoint 

	enhLog_.LogExceptionWithLink errcode%, errmsg$, errline&, methodname$, description$, linkTo, linkcomment$, HotSpotText$
	
	result = True	
	
ExitPoint:	
	enhLogExceptionWithLink = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:enhLogGetCachedErrorTimestamp:3:8


Public Function enhLogGetCachedErrorTimestamp() As String
	enhLogGetCachedErrorTimestamp = ||
	If Not (enhLog_ Is Nothing) Then enhLogGetCachedErrorTimestamp = enhLog_.CachedErrorTimestamp
End Function 

'++LotusScript Development Environment:2:2:enhLogDumpContent:3:8


Public Sub enhLogDumpContent (prefix$, filepath$)
	Dim Text As String
	Dim fileNum As Integer
	
	On Error GoTo ErrorTrap
	
	Call getEnhLog()
	If enhLog_.ActionsIncludeMethodNames Then
		enhLog_.LogAction prefix$ & GetThreadInfo(LIB_LSI_THREAD_CALLPROC) & |():  Called enhLogDumpContent()|
	Else
		enhLog_.LogAction prefix$ & | Called enhLogDumpContent()|
	End If 
	
	If isBlankString(filepath$) Then Error 1200, |FILE NAME IS BLANK|
	If Not fileExists(filepath$) Then Error 1000, |FILE NOT FOUND|
	
	enhLogExtendedContent LIB_PREFIX, |File Contents|, filepath$
	
	fileNum% = FreeFile()
	Open filepath$ For Input As fileNum%
	Do While Not EOF(fileNum%)
		Line Input #fileNum%, text$ 
		enhLogExtendedContent ||, ||, text$
	Loop 
	
	enhLogExtendedContent ||, ||, ||
	
ExitPoint:
	On Error GoTo 0
	Close fileNum%
	Exit Sub
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint
End Sub 

'++LotusScript Development Environment:2:2:enhLogSetResumeOnLoggingFailure:2:8

Public Sub enhLogSetResumeOnLoggingFailure (source As Boolean)
	Call getEnhLog()
	enhLog_.ResumeOnLoggingFailure = source
End Sub 

'++LotusScript Development Environment:2:1:getHashedValue:13:8

%REM
	Function getHashedValue
	Hashes a source String.
	
	Uses the @Password function to perform the hash
	
	@param source$: String to Hash.
	@param clearCache: Flag indicating if cached information should be cleared.
	
	@return	Hashed result.  Blank on Error.	
%END REM
Function getHashedValue(source$, clearCache As Boolean) As String
	Dim extendedInfo As String
	Dim result As String
	On Error GoTo ErrorTrap
	
	Static cache List As String
	
	Dim argument As String 
	
	extendedInfo$ = |Source: | & source$ & Chr(10) & |ClearCache: | & CStr(clearCache)
	result$ = Trim$(source$)
	If (Len(result$) = 0) Then Error ERR_PARAMETER_BLANK, MSG_PARAMETER_BLANK
	If clearCache Then Erase cache
	If IsElement(cache(result$)) Then 
		result$ = cache(result$)
	Else
		argument$ = |@ReplaceSubString(@Text(@Password("| & result$ & |")); "(":")";"")|
		cache(result$) = Trim$(CStr(getScalar(safeEvaluate(argument$, Nothing, ||))))
		If (Len(cache(result$)) = 0) Then 
			Erase cache(result$)
			result$ = ||
		Else
			result$ = cache(result$)
		End If 
	End If 
	
ExitPoint:
	getHashedValue = result$
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	result$ = ||
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:enhLogAction:11:8
%REM 
	Function enhLogAction 
	
	Writes information about an Action to the log if LogActions is enabled. 
	
	@param prefix$ Prefix information 
	@param description$ information to be written to the log. 
	
	@return Flag indicating if the information about the Action was written to the log. 
%END REM
Public Function enhLogAction(prefix$, description$) As Boolean
	Dim result As Boolean
	
	On Error GoTo ErrorTrap
	
	Call getEnhLog()
	If Not enhLog_.LogActions Then GoTo ExitPoint 
	
	If enhLog_.ActionsIncludeMethodNames Then
		enhLog_.LogAction prefix$ & GetThreadInfo(LIB_LSI_THREAD_CALLPROC) & |(): | & description$
	Else
		enhLog_.LogAction prefix$ & description$
	End If 
	
	result = True
	
ExitPoint:	
	enhLogAction = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False	
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:3:enhLogOutputToNotesLog Get:8:8



%REM
	Property Get enhLogOutputToNotesLog
	Indicates if log activity should be recorded using the Events form in the Notes Log (log.nsf by default) 
%END REM
Public Property Get enhLogOutputToNotesLog As Boolean 
	Call getEnhLog()
	enhLogOutputToNotesLog = enhLog_.LogOutputToNotesLog
End Property

'++LotusScript Development Environment:2:1:enhLogGetLogConfigUNID:3:8


Public Function enhLogGetLogConfigUNID() As String
	' Declare the key here instead of globally to avoid change.
	' ATTENTION DEVELOPERS - If you change this key you will loose any existing Log Config documents.
	enhLogGetLogConfigUNID = getConfigUNID(|ENHLOGCONFIG|, False) 
End Function 

'++LotusScript Development Environment:2:1:enhLogGetCachedErrorExtended:2:8

Public Function enhLogGetCachedErrorExtended() As String
	enhLogGetCachedErrorExtended = ||
	If Not (enhLog_ Is Nothing) Then enhLogGetCachedErrorExtended = enhLog_.CachedErrorExtended
End Function 

'++LotusScript Development Environment:2:1:getDocumentByUNID:8:8
%REM
	Gets the document from the current database for the specified UniversalID. 
	
	@param universalID UniversalID of the target document. 
	
	@return Document for the specified UniversalID, or Nothing if not found. 
%END REM
Public Function getDocumentByUNID(ByVal universalID$) As NotesDocument 	
	Dim extendedInfo As String
	Dim result As NotesDocument
	On Error GoTo ErrorTrap
	On Error 4091 GoTo InvalidUNID  ' Error #4091 = Invalid universal id
	
	TrimString universalID$
	extendedInfo$ = |UNID: | & universalID$

	Set result = getCurrentDb().GetDocumentByUNID(universalID$)
	
ExitPoint:
	Set getDocumentByUNID = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	If Not (enhLog_ Is Nothing) Then enhLogException LIB_PREFIX, extendedInfo$
	Set result = Nothing
	Resume ExitPoint	
InvalidUNID:
	On Error GoTo ErrorTrap
	Set result = Nothing
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:getProfiledMethodXML:2:8

Private Function getProfiledMethodXML(pm As ProfiledMethod, includeAll As Boolean) As String 
	Dim extendedInfo As String
	Dim result As String
	On Error GoTo ErrorTrap

	Dim chunks(9) As String 
	
	extendedInfo$ = |ProfiledMethod.module: | & pm.modulename & _ 
	Chr(10) & |ProfiledMethod.classname: | & pm.classname & _
	Chr(10) & |ProfiledMethod.methodname: | & pm.methodname & _
	Chr(10) & |ProfiledMethod.operation: | & pm.operation & _
	Chr(10) & |ProfiledMethod.elapsed: | & CStr(pm.elapsed) & _
	Chr(10) & |ProfiledMethod.ticks: | & CStr(pm.ticks) & _
	Chr(10) & |ProfiledMethod.calls: | & CStr(pm.calls) & _
	Chr(10) & |ProfiledMethod.Max Recursion Depth: | & CStr(pm.maxrecursiondepth) & _
	Chr(10) & |ProfiledMethod.Recursions: | & CStr(pm.recursions) & _
	Chr(10) & |ProfiledMethod.isStarted: | & CStr(pm.isStarted) 
	If (Len(Trim$(pm.methodname)) = 0) Then Error ERR_PARAMETER_BLANK, MSG_PARAMETER_BLANK
	
	If (Len(pm.methodname) > 0) Then chunks(0) = |name="| & LCase$(pm.methodname) & |"|
	If (Len(pm.operation) > 0) Then chunks(1) = |o="| & LCase$(pm.operation) & |"|
	chunks(2) = |c="| & CStr(pm.calls) & |"|
	chunks(3) = |et="| & CStr(pm.elapsed) & |"|
	If (pm.recursions > 0) Then chunks(4) = |r="| & CStr(pm.recursions) & |"|
	If (pm.maxrecursiondepth > 0) Then chunks(5) = |mr="| & CStr(pm.maxrecursiondepth) & |"|
	
	If includeAll Then 
		chunks(6) = |t="| & CStr(pm.ticks) & |"|
		chunks(7) = |is="| & CStr(pm.isStarted) & |"|
		If (Len(pm.modulename) > 0) Then chunks(8) = |m="| & LCase$(pm.modulename) & |"|
		If (Len(pm.classname) > 0) Then chunks(9) = |class="| & LCase$(pm.classname) & |"|
	End If 
	
	result$ = |<method | & Join(FullTrim(chunks), | |) & | />|
	
ExitPoint:
	getProfiledMethodXML = result$
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	result$ = ||
	Resume ExitPoint
End Function

'++LotusScript Development Environment:2:1:enhLogGetProfiledMethodsXMLstream:10:8

%REM
	Function enhLogGetProfiledMethodsXMLstream
	Gets an XML stream containing information about all profiled methods.
	
	@param includeAll: Flag indicating if all Profiled Method properties should be included.

	@return XML contining information about profiled methods.  Nothing on Error or Profiling Disabled.	
%END REM
Public Function enhLogGetProfiledMethodsXMLstream(includeAll As Boolean) As NotesStream 
	Dim modules List As NestedProfiledMethodList
	Dim target As ProfiledMethod

	Dim extendedInfo As String
	Dim result As NotesStream

	Dim tag As String

	On Error GoTo ErrorTrap


	If (genhl_ProfiledMethods Is Nothing) Then Set genhl_ProfiledMethods = New ProfiledMethodList() 
	
	ForAll pe In genhl_ProfiledMethods.content 
		Set target = pe  
		extendedInfo$ = |Module: | & target.ModuleName & _ 
		Chr(10) & |Class: | & target.ClassName & _ 
		Chr(10) & |Method: | & target.MethodName & _ 
		Chr(10) & |Operation: | & target.Operation
		
		tag$ = target.MethodName
		If (Len(target.Operation) > 0) Then tag$ = tag$ & |.| & target.Operation 
		
		If (Not IsElement(modules(target.ModuleName))) Then Set modules(target.ModuleName) = New NestedProfiledMethodList()
		If (Not IsElement(modules(target.ModuleName).content(target.ClassName))) Then Set modules(target.ModuleName).content(target.ClassName) = New ProfiledMethodList()
		Set modules(target.ModuleName).content(target.ClassName).content(tag$) = target		
	End ForAll 


	If (Len(tag$) > 0) Then 
		Set result = getCurrentSession().CreateStream() 
		Call result.WriteText(|<profiledmethods>|, EOL_CR)
		ForAll npl In modules 
			Call result.writeText(|<module name="| & LCase$(ListTag(npl)) & |">|, EOL_CR)
			ForAll pml In npl.content 
				tag$ = LCase$(ListTag(pml))
				If (Len(tag$) > 0) Then Call result.WriteText(|<class name="| & tag$ & |">|, EOL_CR)
				ForAll pm In pml.content 
					Call result.WriteText(getProfiledMethodXML(pm, includeAll), EOL_CR)
				End ForAll 
				
				If (Len(tag$) > 0) Then Call result.WriteText(|</class>|, EOL_CR)
			End ForAll 
			
			Call result.writeText(|</module>|, EOL_CR)
		End ForAll 
		
		Call result.WriteText(|</profiledmethods>|, EOL_CR)
		result.Position = 0
	End If 


ExitPoint:
	Set enhLogGetProfiledMethodsXMLstream = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	Set result = Nothing
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:enhLogMethodResult:2:8

Public Function enhLogMethodResult (prefix$, description$) As Boolean
	Dim result As Boolean
	
	On Error GoTo ErrorTrap
	
	Call getEnhLog()
	If Not enhLog_.LogMethodResults Then GoTo ExitPoint 
	
	If enhLog_.ActionsIncludeMethodNames Then
		enhLog_.LogMethodResult prefix$ & GetThreadInfo(LIB_LSI_THREAD_CALLPROC) & |(): | & description$
		enhLogExtendedContent ||, ||, ||
	Else
		enhLog_.LogMethodResult prefix$ & description$
	End If 
	
	result = True
	
ExitPoint:	
	enhLogMethodResult = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False	
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:getListSize:5:8
%REM
	Function getListSize
	Description: Gets the size of a list 
%END REM
Public Function getListSize(source As Variant) As Long 
	Dim result&
	
	If IsList(source) Then 
		ForAll element In source
			result& = result& + 1
		End ForAll
	Else 
		result& = 0 
	End If 
	
	getListSize& = result&
	
End Function

'++LotusScript Development Environment:2:1:enhLogGetNotesLogForm:5:8
%REM
	Function enhLogGetNotesLogForm
	Gets the name of the form used for logging
%END REM
Public Function enhLogGetNotesLogForm() As String 
		enhLogGetNotesLogForm = FORMALIAS_EVENTS  
End Function

'++LotusScript Development Environment:2:1:enhLogGetTaggedTicks:9:8

%REM
	Function enhLogGetTaggedTicks
	Returns the number of clock ticks for a given tag since last called.

	@param tag$: Unique string identifying the specific timer value to retrieve.
	@return: Number of clock ticks since last called.
%END REM
Public Function enhLogGetTaggedTicks(tag$) As Double
	Dim extendedInfo As String	
	Dim result As Double
	On Error GoTo ErrorTrap
	
	Static cache List As Double
	Dim thismoment As Double	
	
	result# = 0
	thismoment# = GetThreadInfo(LIB_LSI_THREAD_TICKS)
	If IsElement(cache(tag$)) Then result# = thismoment# - cache(tag$)

ExitPoint:
	cache(tag$) = thismoment# 
	enhLogGetTaggedTicks = result#
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	result# = 0
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:enhLogGetProfileMethodTriggerCount:10:8

%REM
	Function enhLogGetProfileMethodTriggerCount
	Appends the clock ticks for a specified methodname to the global profile list.
	
	@param source$: Name of Method being profiled.
	
	@return Flag indicating if the profile for the methodname was successfully updated.
%END REM
Public Function enhLogGetProfileMethodTriggerCount(source$) As Long 
	Dim extendedInfo As String
	Dim result As Long
	On Error GoTo ErrorTrap

	Static cache List As Long
	Static isLoaded As Boolean
	
	Dim ndoc As NotesDocument 
	Dim item As NotesItem
	Dim values As Variant 
	Dim chunks As Variant
	Dim elementtext As String  
	Dim tag As String

	tag$ = UCase$(Trim$(source$))
		
	If (Not isLoaded) Then 
		extendedInfo$ = |Method Name: | & source$
		If (Len(tag$) = 0) Then Error ERR_PARAMETER_BLANK, MSG_PARAMETER_BLANK

		Set ndoc = enhLogGetLogConfigDoc(False)
		If (Not (ndoc Is Nothing)) Then 
			If ndoc.HasItem(ITEMNAME_ENHLOG_PROFILEMETHODCOUNT) Then 
				values = ndoc.GetItemValue(ITEMNAME_ENHLOG_PROFILEMETHODCOUNT)
				ForAll element In values
					elementtext$ = CStr(element)
					extendedInfo$ = |Method Name: | & source$ & _  
					Chr(10) & |Element: | & elementtext$
					If (InStr(elementtext$, "|") > 0) Then 
						chunks = Split(elementtext$, "|")
						If IsNumeric(chunks(1)) Then cache(UCase$(Trim$(chunks(0)))) = CLng(chunks(1))
					End If 
				End ForAll 
				
			End If 
		End If 
	
		isLoaded = True	
	End If 
	
	If IsElement(cache(tag$)) Then result = cache(tag$)
		
ExitPoint:
	enhLogGetProfileMethodTriggerCount = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	result = False
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:2:enhLogSetOverwriteFile:2:8

Public Sub enhLogSetOverwriteFile (source As Boolean)
	Call getEnhLog()
	enhLog_.OverwriteFile = source
End Sub 

'++LotusScript Development Environment:2:1:getListTags:7:8
%REM
	Function getListTags
	Description: Gets the listTags for a list 
	@param source: List object from which to get the list tags 
	@return array of listTags from the list. 
%END REM
Public Function getListTags(source As Variant) As Variant  
	Dim result As Variant 
	On Error GoTo ErrorTrap 

	result = Null 
	If Not IsList(source) Then GoTo ExitPoint 
	
	Dim valuesArray() As String
	Dim i#
	
	' get the size first!  faster than multiple redim calls.
	i# = getListSize(source) 
	If (i# < 1) Then GoTo ExitPoint 

	ReDim valuesArray(i# - 1) As String 

	' populate the array with the listTags
	i# = 0
	ForAll element In source 
		valuesArray(i#) = ListTag(element) 
		i# = i# + 1
	End ForAll

	result = valuesArray
	
ExitPoint: 
	getListTags = result 
	Exit Function 
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, ||
	result = Null
	Resume ExitPoint 
End Function

'++LotusScript Development Environment:2:1:enhLogProfileMethodStart:11:8

%REM
	Function enhLogProfileMethodStart
	Appends the clock ticks for a specified method to the global profile list.
	
	@param classname$: Class for calling Method.
	@param operation$: Identifies "GET" or "SET" operation of calling properties.
	
	@return Number of clock ticks since enhLogProfileMethodStart() for the method was called.
%END REM
Public Function enhLogProfileMethodStart(ByVal classname$, ByVal operation$) As Double 
	Dim target As ProfiledMethod

	Dim extendedInfo As String
	Dim result As Double

	Dim chunks(3) As String 
	Dim tag As String
	Dim c_method As String 
	Dim c_module As String 
	Dim ticks As Double 
	
	On Error GoTo ErrorTrap

	If enhLogIsProfilingEnabled() Then
		TrimString classname$ 
		operation$ = UCase$(Trim$(operation$))
		c_module$ = GetThreadInfo(LIB_LSI_THREAD_CALLMODULE)
		c_method$ = GetThreadInfo(LIB_LSI_THREAD_CALLPROC)	
		chunks(0) = c_module$
		chunks(1) = classname$
		chunks(2) = c_method$
		chunks(3) = operation$
		tag$ = UCase$(Join(FullTrim(chunks), DEFAULT_DELIMITER))
		extendedInfo$ = |Tag: | & tag$

		Set target = genhl_ProfiledMethods.getValue(tag$) 
		If (target Is Nothing) Then 
			extendedInfo$ = |enhLogProfileMethodStart() has not yet been called for the Profiled Method.| & _ 
			Chr(10) & |Calling Module: | & c_module$ & _ 
			Chr(10) & |Calling Class: | & classname$ & _ 
			Chr(10) & |Calling Method: | & c_method$ & _ 
			Chr(10) & |Calling Operation: | & operation$ & _ 
			Chr(10) & extendedInfo$

			Set target = New ProfiledMethod(c_module$, classname$, c_method$, operation$, GetThreadInfo(LIB_LSI_THREAD_TICKS))
			Set genhl_ProfiledMethods.content(tag$) = target
			If (target Is Nothing) Then Error ERR_OPERATION_FAILED, MSG_OPERATION_FAILED 
		End If
		
		target.calls = target.calls + 1
		ticks# = GetThreadInfo(LIB_LSI_THREAD_TICKS)

		If target.isStarted Then 
			target.recursions = target.recursions + 1
			target.recursiondepth = target.recursiondepth + 1
			If (target.recursiondepth > target.maxrecursiondepth) Then target.maxrecursiondepth = target.recursiondepth
			target.elapsed = target.elapsed + (ticks# - target.ticks) 
			target.ticks = ticks#
		End If 
		
		target.isStarted = True
		Set genhl_ProfiledMethods.content(tag$) = target
	End If 
		
ExitPoint:
	enhLogProfileMethodStart = result#
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:enhLogWarningWithLink:2:8

Public Function enhLogWarningWithLink (prefix$, description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$) As Boolean
	Dim extendedcontent$
	Dim result As Boolean
	
	On Error GoTo ErrorTrap

	
	Call getEnhLog()
	If enhLog_.ActionsIncludeMethodNames Then
		extendedcontent$ = prefix$ & GetThreadInfo(LIB_LSI_THREAD_CALLPROC) & |(): | & description$
	Else
		extendedcontent$ = prefix$ & description$
	End If 
	
	enhLog_.LogWarningWithLink extendedcontent$, linkTo, linkcomment$, HotSpotText$
	
	result = True
	
ExitPoint:	
	enhLogWarningWithLink = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = Err()	
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:4:enhLogContentToNotesLog Set:11:8



%REM
	Property Set enhLogContentToNotesLog
	Specifies if log activity should be recorded using the Events form in the Notes Log (log.nsf by default) 
		
	@deprecated - use enhLogOutputToNotesLog 
	@see enhLogOutputToNotesLog
%END REM
Public Property Set enhLogContentToNotesLog As Boolean 
	Dim extendedinfo$
	On Error GoTo ErrorTrap
	
	enhLogOutputToNotesLog = enhLogContentToNotesLog 
	
	extendedinfo$ = |Calling Method: | & GetThreadInfo(LIB_LSI_THREAD_CALLPROC)
	Error ERR_METHOD_DEPRECATED, MSG_METHOD_DEPRECATED & |Use enhLogOutputToNotesLog|
	
ExitPoint:
	Exit Property
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedinfo$
	Resume ExitPoint 	 	
End Property

'++LotusScript Development Environment:2:1:getDbConfigDoc:14:8


%REM
	Function getDbConfigDoc
	Gets the DbConfig document for the specified Form.
	
	Only 1 DbConfig document may exist for a specified form.
	
	@param source$ Form for the specified DbConfig document.
	@param clearCache Flag indicating if the cached information should be cleared.
	
	@return NotesDocument for the specified key.  Returns Nothing if no document found.	
%END REM
Public Function getDbConfigDoc(ByVal source$, clearCache As Boolean) As NotesDocument
	Dim extendedInfo As String
	Dim result As NotesDocument
	On Error GoTo ErrorTrap
	
	Dim nvw As NotesView
	Dim column As NotesViewColumn
	Dim killdoc As NotesDocument
	Dim nitm As NotesItem
	Dim unid As String
	Dim oldunid As String
	Dim form As String 
	Dim docform As String
	
	Dim isCreated As Boolean
	
	TrimString source$
	form$ = UCase$(source$)
	extendedInfo$ = |Form: | & source$
	If (Len(form$) < 1) Then Error ERR_PARAMETER_BLANK, MSG_PARAMETER_BLANK
	
	If clearCache Then
		Erase genhl_dbConfigDocCache
	ElseIf IsElement(genhl_dbConfigDocCache(form$)) Then 
		Set result = genhl_dbConfigDocCache(form$)
		GoTo ExitPoint
	End If 
	
	unid$ = getConfigUNID(form$, clearCache) 
	extendedInfo$ = |Form: | & form$ & Chr(10) & |ClearCache: | & CStr(clearCache) & Chr(10) & |UNID: | & unid$
	Set result = getDocumentByUNID(unid$) 
	If (result Is Nothing) Then 
		' get from view  (create if necessary)
		extendedInfo$ = extendedInfo$ & Chr(10) & |View: | & VIEWNAME_DBCONFIG 
		Set nvw = getCurrentDb().GetView (VIEWNAME_DBCONFIG) 
		If (nvw Is Nothing) Then 
			' create the view 
			enhLogAction LIB_PREFIX, |Creating Temporary View: | & VIEWNAME_DBCONFIG
			Set nvw = getCurrentDb().CreateView(VIEWNAME_DBCONFIG, |SELECT @Contains ( Form; "Config" )|)
			Set column = nvw.CreateColumn(1, |Form|, |@UpperCase(Form)|)
			column.isSorted = True
			Set column = nvw.CreateColumn(2, |Modified|, |@Modified|)
			column.isSorted = True
			Call nvw.Refresh()
			isCreated = True
		End If 
		
		Set result = nvw.GetDocumentByKey(form$, True)
		If isCreated Then 
			' delete the temporary view
			enhLogAction LIB_PREFIX, |Removing Temporary View: | & VIEWNAME_DBCONFIG
			Call nvw.Remove() 
		End If 
		
		If (Not (result Is Nothing)) Then 
			enhLogWarning LIB_PREFIX, |Found "| & source$ & |" Document with invalid UNID.|
			oldunid$ = result.UniversalID
			extendedInfo$ = extendedInfo$ & Chr(10) & |Old UNID: | & oldunid$
			enhLogExtendedContent LIB_PREFIX, |Changing UNID of "| & source$ & |" Document|, |Old UNID: | & oldunid$
			enhLogExtendedContent ||, ||, |New UNID: | & unid$
			enhLogExtendedContent ||, ||, ||
			result.UniversalID = unid$
			If (Not result.Save(True, False)) Then Error ERR_DOC_NOT_SAVED, MSG_DOC_NOT_SAVED
			Set killdoc = getDocumentByUNID(oldunid$)
			Call killdoc.Remove(True)
		End If	
	End If 
	
	If (result Is Nothing) Then 
		enhLogWarning LIB_PREFIX, |No document found for | & source$
		Set result = New NotesDocument(getCurrentDb())
		result.UniversalID = getConfigUNID(unid$, False)
		Set nitm = result.ReplaceItemValue(ITEMNAME_FORM, source$)
		nitm.IsSummary = True		
		enhLogExtendedContent LIB_PREFIX, |Created New "| & source$ & |" Document|, |UNID: | & unid$
		enhLogExtendedContent ||, ||, ||
	End If 
	
	docform$ = UCase$(Trim$(getDocItemText(result, ITEMNAME_FORM)))	
	If (docform$ <> form$) Then 
		enhLogWarning LIB_PREFIX, |Document form "| & docform$ & |" does not match specified config form "| & form$ & |"|
		enhLogAction LIB_PREFIX, |Changing Form to: | & form$
		Set nitm = result.ReplaceItemValue(ITEMNAME_FORM, form$)
		nitm.IsSummary = True		
	End If 
	
ExitPoint:
	Set genhl_dbConfigDocCache(form$) = result
	Set getDbConfigDoc = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	Set result = Nothing
	Resume ExitPoint
End Function  

'++LotusScript Development Environment:2:1:checkCreateDirectory:8:8
%REM
	Function checkCreateDirectory
	Verifies that a target directory exists under a root directory, and conditionally creates it if not. 
	
	@return full directory (root & target concatenated with the appropriate delimiter) if target exists or was created.  
	Empty string ("") on failure. 
%END REM
Private Function checkCreateDirectory(root$, target$) As String 

	Const ATTR_DIRECTORY = 16

	' exception variables
	Dim extendedinfo List As String 
	Dim msg$ 
	
	Dim chunks As Variant 
	
	Dim result$
	Dim directory$ 
	Dim found As Boolean 
	
	
	' BEGIN CODE
	If isBlankString(root$) Then Error ERR_PARAMETER_BLANK, MSG_PARAMETER_BLANK & |Root is blank.  |
	If isBlankString(root$) Then Error ERR_PARAMETER_BLANK, MSG_PARAMETER_BLANK & |Target is blank.  |
	On Error GoTo ErrorTrap
	
	extendedinfo(|Root|) = root$
	extendedinfo(|Target|) = target$ 

	result$ = root$ & FILEPATH_DELIMITER & target$ 
	extendedinfo(|Result|) = result$
	On Error Resume Next 
	directory$ = Dir$(result$, ATTR_DIRECTORY)
	On Error GoTo ErrorTrap
	Do While Not isBlankString(directory$)
		extendedinfo(|Directory|) = directory$ 
		If (0 = StrCompare(directory$, target$, 0)) Then GoTo ExitPoint
		directory$ = Dir$ 
	Loop	
	
	' If here then the directory was not found.  Attempt to create it. 
	MkDir result$ 

ExitPoint:
	While StrRightBack(result$, 1) = FILEPATH_DELIMITER 
		result$ = Left$(result$, Len(result) -1)
	Wend 
	checkCreateDirectory = result$
	Exit Function 
ErrorTrap:
	On Error GoTo 0 
	result$ = || ' any error should force an empty string to be returned. 
	ForAll s In extendedinfo
		If isBlankString(msg$) Then 
			msg$ = ListTag(s) & |: | & s
		Else 
			msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
		End If
	End ForAll
	enhLogException LIB_PREFIX, msg$
	Resume ExitPoint
End Function

'++LotusScript Development Environment:2:1:fileExists:9:8
 
%REM 
	Checks to see if a file exists.
	
	@param filepath$ filepath to check for existence. 
	
	@return Flag indicating if filepath was found.
%END REM
Public Function fileExists (filepath$) As Boolean
	Dim extendedInfo As String
	Dim result As Boolean
	
	On Error GoTo ErrorTrap
	extendedInfo$ = |"| & filepath$ & |"|
	result = (Len(Dir(filepath$, 14)) > 0) ' ATTR_NORMAL + ATTR_HIDDEN + ATTR_SYSTEM + ATTR_VOLUME
	
	
ExitPoint:
	fileExists = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False
	Resume ExitPoint
End Function   

'++LotusScript Development Environment:2:1:enhLogGetTaggedMilliseconds:9:8

%REM
	Function enhLogGetTaggedMilliseconds
	Returns the number of milliseconds for a given tag since last called.

	@param tag$: Unique string identifying the specific timer value to retrieve.
	@return: Number of clock ticks since last called.
%END REM
Public Function enhLogGetTaggedMilliseconds(tag$) As Double
	Dim extendedInfo As String	
	Dim result As Double
	On Error GoTo ErrorTrap
	
	Static cache List As Double
	Dim thismoment As Double	
	
	result# = 0
	thismoment# = GetThreadInfo(LIB_LSI_THREAD_TICKS)
	If IsElement(cache(tag$)) Then result# = enhLogTicksToMilliseconds(thismoment# - cache(tag$))

ExitPoint:
	cache(tag$) = thismoment# 
	enhLogGetTaggedMilliseconds = result#
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	result# = 0
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:enhLogTicksPerSecond:9:8

%REM
	Function enhLogTicksPerSecond
	
	Returns the number of Clock Ticks which occur per second.
	
	@return Number of Clock Ticks per second.  -1 on Error.
%END REM
Public Function enhLogTicksPerSecond() As Long 
	Dim extendedInfo As String
	Static result As Long
	On Error GoTo ErrorTrap

	If (result& = 0) Then result& = CLng(GetThreadInfo(LIB_LSI_THREAD_TICKS_PER_SEC))

ExitPoint:
	enhLogTicksPerSecond = result&
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	result& = -1
	Resume ExitPoint
End Function 'enhLogTicksPerSecond

'++LotusScript Development Environment:2:1:enhLogGetLogConfigDb:8:8

%REM
	Function enhLogGetLogConfigDb
	Gets an open instance of the Database defined in the Log Config document.
	
	@return Database defined in the Log Config document.  Nothing on Error.
%END REM
Public Function enhLogGetLogConfigDb() As NotesDatabase 
	Dim extendedInfo As String
	Dim result As NotesDatabase
	On Error GoTo ErrorTrap

	Dim ndoc As NotesDocument 
	Dim server As String 
	Dim filepath As String

	Set ndoc = enhLogGetLogConfigDoc(False)
	server$ = getDocItemText(ndoc, ITEMNAME_ENHLOG_TARGET_SERVER)
	filepath$ = getDocItemText(ndoc, ITEMNAME_ENHLOG_TARGET_FILEPATH)
	extendedInfo$ = |Server: | & server$ & _ 
	Chr(10) & |Filepath: | & filepath$
	
	Set result = getOpenDatabase(server$, filepath$) 
	
ExitPoint:
	Set enhLogGetLogConfigDb = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	Set result = Nothing
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:3:enhLogContentToNotesLog Get:11:8



%REM
	Property Get enhLogContentToNotesLog
	Indicates if log activity should be recorded using the Events form in the Notes Log (log.nsf by default) 
	
	@deprecated - use enhLogOutputToNotesLog 
	@see enhLogOutputToNotesLog
%END REM
Public Property Get enhLogContentToNotesLog As Boolean 
	Dim extendedinfo$
	On Error GoTo ErrorTrap
	
	extendedinfo$ = |Calling Method: | & GetThreadInfo(LIB_LSI_THREAD_CALLPROC)
	Error ERR_METHOD_DEPRECATED, MSG_METHOD_DEPRECATED & |Use enhLogOutputToNotesLog|
	
ExitPoint:
	enhLogContentToNotesLog = enhLogOutputToNotesLog
	Exit Property
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedinfo$
	Resume ExitPoint 	 	 	
End Property

'++LotusScript Development Environment:2:1:isBlankString:7:8


%REM
	Function isBlankString
	Description: Comments for Function
%END REM
Public Function isBlankString(source$) As Boolean 
	Dim result As Boolean 
	
	result = (Len(FullTrim(source$)) < 1) 
	
ExitPoint:
	isBlankString = result 
	Exit Function 
ErrorTrap:
	On Error GoTo 0
	result = True 
	Resume ExitPoint 
End Function

'++LotusScript Development Environment:2:2:enhLogSetUserName:2:8

Public Sub enhLogSetUserName (source As NotesName)
	Call getEnhLog()
	Set enhLog_.UserName = source
End Sub 

'++LotusScript Development Environment:2:1:getScalarString:9:8
%REM
	Function getScalarString
	Gets the scalar value of an object as a string 
	
	@param source variant from which to get the scalar value
	
	@return Scalar value of the object. 
%END REM
Public Function getScalarString(source As Variant) As String 
	On Error GoTo ErrorTrap
	
	Dim result$
	
	' BEGIN CODE
	
	result$ = CStr(getScalar(source))
	
ExitPoint: 
	getScalarString = result
	Exit Function 
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint
End Function

'++LotusScript Development Environment:2:1:enhLogHasCachedError:2:8

Public Function enhLogHasCachedError() As Boolean
	enhLogHasCachedError = False
	If Not (enhLog_ Is Nothing) Then enhLogHasCachedError = enhLog_.hasCachedError
End Function 

'++LotusScript Development Environment:2:1:safeEvaluate:11:8
%REM  
	Function safeEvaluate 
	Evaluates a formula and returns the result. 
	
	@param formula$ Formula to evaluate
	@param context Context object for which the formula should be run
	@param failValue Value to return in the event of a failure.
	
	@return Result of the evaluated formula, or failValue if a failure occurs. 
%END REM
Public Function safeEvaluate(ByVal formula$, context As Variant, failValue As Variant) As Variant
		Dim extendedInfo As String
		Dim result As Variant
		Dim syntax As Variant
		On Error GoTo ErrorTrap

		formula$ = strReplaceSubstring(strReplaceSubstring(Trim$(formula$), {”},{"}),{“},{"})
		extendedInfo$ = |Formula: | & formula$
		If (Len(formula$) = 0) Then Error ERR_PARAMETER_BLANK, MSG_PARAMETER_BLANK
		
		Let syntax = Evaluate(|@CheckFormulaSyntax({| & formula$ & |})|)
		If (Not(syntax(0) = |1|)) Then
			Error ERR_FORMULA_INVALID, MSG_FORMULA_INVALID & | (| & syntax(0) & |: | & syntax(5) & |)|
		End If
		If (context Is Nothing) Then
			result = Evaluate(formula$)
		Else
			result = Evaluate(formula$, context)
		End If  
		
		
ExitPoint:
	If IsObject(result) Then 
		Set safeEvaluate = result
	Else
		safeEvaluate = result
	End If 
	Exit Function
ErrorTrap:
	On Error GoTo 0
	If Not (enhLog_ Is Nothing) Then enhLogException LIB_PREFIX, extendedInfo$
	If IsObject(failValue) Then 
		Set result = failValue
	Else
		result = failValue
	End If 
	Resume ExitPoint
End Function   

'++LotusScript Development Environment:2:1:enhLogTicksToMilliseconds:10:8

%REM
	Function enhLogTicksToMilliseconds
	
	Converts the number of Clock Ticks into Milliseconds.
	
	@param source#double: Number of clock ticks to convert.
	@return Number of milliseconds represented by the given number of clock ticks.
%END REM
Public Function enhLogTicksToMilliseconds(source#) As Double 
	Dim extendedInfo As String
	Dim result As Double
	On Error GoTo ErrorTrap

	Dim wholeTicks As Double

	extendedInfo$ = |Source: | & CStr(source#)
	wholeTicks# = Fix(source#)
	extendedInfo$ = extendedInfo$ & Chr(10) & |Clock Ticks: | & CStr(wholeTicks#)
	If (wholeTicks# > 0) Then
		If (enhLogTicksPerSecond() > 0) Then 
			result# = Fix(wholeTicks# / (enhLogTicksPerSecond() / 1000))
		Else
			result# = wholeTicks#
		End If 
	End If 
	 
ExitPoint:
	enhLogTicksToMilliseconds = result#
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	result# = -1
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:enhLogExtendedContent:12:8
%REM 
	Function enhLogExtendedContent 
	
	Writes ExtendedContent information about an Action to the log if LogActions is enabled. 
	
	@param prefix$ Prefix information 
	@param description$ information to be written to the log.
	@param extendedcontent$ extended content information. 
	
	@return Flag indicating if the information about the Action was written to the log. 
%END REM
Public Function enhLogExtendedContent (prefix$, description$, extendedcontent$) As Boolean
	Dim result As Boolean
	
	On Error GoTo ErrorTrap
	
	Call getEnhLog()
	If isBlankString(description$ & prefix$) Then 
		enhLog_.LogExtendedContent ||, extendedcontent$
	Else
		If enhLog_.ActionsIncludeMethodNames Then
			enhLog_.LogExtendedContent prefix$ & GetThreadInfo(LIB_LSI_THREAD_CALLPROC) & |(): | & description$, extendedcontent$
		Else
			enhLog_.LogExtendedContent prefix$ & description$, extendedcontent$
		End If 
	End If 
	
	result = True
	
ExitPoint:	
	enhLogExtendedContent = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:createRichTextStyle:3:8
	

Private Function createRichTextStyle (Bold As Boolean, Effects%, FontSize%, Italic As Boolean, NotesColor%, NotesFont%, PassThruHTML As Boolean, Strikethrough As Boolean, Underline As Boolean) As NotesRichTextStyle
	Dim nrtstyle As NotesRichTextStyle
	
	Set nrtstyle = getCurrentSession().createRichTextStyle
	With nrtstyle
		.Bold = Bold
		.Effects = Effects
		.FontSize = FontSize
		.Italic = Italic
		.NotesColor = NotesColor
		.NotesFont = NotesFont
		.Strikethrough = Strikethrough
		.Underline = Underline
		.PassThruHTML = PassThruHTML
	End With 
	
	Set createRichTextStyle = nrtstyle
End Function 

'++LotusScript Development Environment:2:1:enhLogSave:2:8

Public Function enhLogSave(force As Boolean, createResponse As Boolean)
	Call getEnhLog()
	enhLogSave = enhLog_.save(force, createResponse)
End Function 

'++LotusScript Development Environment:2:1:getEnhLog:7:8
%REM
	Function getEnhLog 
	Gets the EnhancedLog object
	
	@return EnhancedLog object
%END REM
Public Function getEnhLog() As EnhancedLog 
	Dim errcode%
	Dim errmsg$

	On Error GoTo ErrorTrap
	
	errcode% = 0
	errmsg$ = ||
	
	If (enhLog_ Is Nothing) Then 
		Call InstantiateLoggingSession()
		Set enhLog_ = New EnhancedLog(||) 
		If (enhLog_ Is Nothing) Then Error ERR_OBJECT_CREATE_FAILED, MSG_OBJECT_CREATE_FAILED
	End If 

	
ExitPoint:
	If (errcode% <> 0) Then Error errcode%, errmsg$ 
	Set getEnhLog = enhLog_ 
	Exit Function 
ErrorTrap:
	On Error GoTo 0
	errcode% = Err()
	errmsg$ = Error()
	enhLogException LIB_PREFIX, || 
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:enhLogIsLogDisabled:3:8


Public Function enhLogIsLogDisabled() As Boolean
	Static result As Boolean
	Dim extendedInfo As String
	On Error GoTo ErrorTrap
	
	Static isChecked As Boolean
	
	If isChecked Then GoTo ExitPoint 
	result = (|YES| <> UCase$(enhLogGetLogConfigText(ITEMNAME_ENHLOG_YN_LOGENABLED)))
	isChecked = True
	
ExitPoint:	
	enhLogIsLogDisabled = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False	
	enhLogException LIB_PREFIX, extendedInfo$
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:getLogOptionsProfile:3:8


Private Function getLogOptionsProfile() As NotesDocument
	Dim extendedInfo As String
	Static result As NotesDocument
	On Error GoTo ErrorTrap
	
	Static checked As Boolean
	Dim fieldnames As Variant
	
	If checked Then GoTo ExitPoint	
	extendedInfo$ = |Profile document name: | & PROFILENAME_ENHANCEDLOG
	Set result = getCurrentSession().CurrentDatabase.GetProfileDocument(PROFILENAME_ENHANCEDLOG)
	If result.IsNewNote Then Set result = Nothing
	If (result Is Nothing) Then GoTo ExitPoint
	
	fieldnames = enhLogOptionsProfileFieldNames
	ForAll fieldname In fieldnames
		If (Not result.HasItem(fieldname)) Then 
			Set result = Nothing
			GoTo ExitPoint
		End If
	End ForAll 
	
ExitPoint:
	checked = True
	Set getLogOptionsProfile = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	If Not (enhLog_ Is Nothing) Then enhLogException LIB_PREFIX, extendedInfo$
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:getConfigUNID:13:8

%REM
	Function getConfigUNID
	Gets the UNID of the DbConfig document for a given source key.
	
	Only 1 DbConfig document may exist for a specified form.
	
	@param source$:  Form of the specified DbConfig document.
	@param clearCache: Flag indicating if cached information should be cleared.
	
	@return	UNID for the Config doc.  Blank on Error.	
%END REM
Public Function getConfigUNID(ByVal source$, clearCache As Boolean) As String
	Dim extendedInfo As String
	Dim result As String
	On Error GoTo ErrorTrap
	
	Static cache List As String
	Dim envarName As String
	
	source$ = UCase$(Trim$(source$))
	
	extendedInfo$ = |Source: | & source$ & Chr(10) & |ClearCache: | & CStr(clearCache)
	envarName$ = getEnvarName(source$, clearCache)
	If (Len(envarName$) = 0) Then GoTo ExitPoint
	
	If clearCache Then Erase cache	
	envarName$ = UNID_PREFIX & envarName$	
	extendedInfo$ = extendedInfo$ & Chr(10) & |Environment Variable Name: | & envarName$
	If IsElement(cache(envarName$)) Then 
		result$ = cache(envarName$)
	Else
		result$ = getHashedValue(source$, clearCache)
		If (Len(result$) = 0) Then Error ERR_OPERATION_FAILED, MSG_OPERATION_FAILED
	End If 
	
ExitPoint:
	cache(envarName$) = result$
	getConfigUNID = result$
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	result$ = ||
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:isStringArrayEmpty:3:8


Private Function isStringArrayEmpty (source As Variant) As Boolean
	Dim result As Boolean
	Dim sourceType As String
	Dim extendedInfo As String
	
	

	On Error GoTo ErrorTrap
	
	sourceType$ = TypeName(source)
	
	Select Case sourceType$
	Case |STRING|
		result = (Len(Trim$(source)) = 0)
		
	Case |STRING( )|
		result = True
		ForAll element In source
			result = Not (Len(Trim$(source)) = 0)
			If Not result Then GoTo ExitPoint
		End ForAll 	
		
	Case Else 
		extendedInfo$ = |Parameter must be a String or an array of Strings.| & _ 
		Chr(10) & |Parameter type = | & sourceType$ & |.|
		
		Error ERR_PARAMETER_INVALID, MSG_PARAMETER_INVALID
	End Select 	
	
ExitPoint:	
	isStringArrayEmpty = result
	Exit Function	
ErrorTrap:
	On Error GoTo 0 
	enhLogException LIB_PREFIX, extendedInfo$
	Resume ExitPoint 
End Function 

'++LotusScript Development Environment:2:1:enhLogGetLatestLog:2:8

Public Function enhLogGetLatestLog() As NotesDocument
	Static nvw As NotesView
	Dim result As NotesDocument
	
	
	On Error GoTo ErrorTrap
	
	Call getEnhLog()
	If (nvw Is Nothing) Then 
		Set nvw = enhLog_.TargetDatabase.getView(VIEWNAME_LOGS_BYLOGTIME)
		
		If (nvw Is Nothing) Then Error ERR_VIEW_NOT_FOUND , MSG_VIEW_NOT_FOUND  & _ 
		| | & VIEWNAME_LOGS_BYLOGTIME
	Else
		Call nvw.Refresh()
	End If 
	
	Set result = nvw.GetFirstDocument()
	
ExitPoint:
	enhLogMethodResult LIB_PREFIX, CStr( Not (result Is Nothing))
	Set enhLogGetLatestLog = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, ||
	Set result = Nothing
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:stripFirstSubstr:12:8


%REM  THIS METHOD INTENTIONALLY HAS NO ERROR TRAPPING
	Function stripFirstSubstr 
	Strips the first substring from a string and returns the result
	
	@param source$  String within which to search 
	@param searchfor$ String to search for within source
	
	@return source with the first instance of searchfor removed
%END REM ERRORS MUST BE HANDLED BY CALLING CODE
Public Function stripFirstSubstr (source$, searchfor$) As String
	
	If (InStr(source$, searchfor$) > 0) Then
		stripFirstSubstr$ = StrLeft(source$, searchfor$) & StrRight(source$, searchfor$)
	Else
		stripFirstSubstr$ = source$
	End If 
	
End Function  

'++LotusScript Development Environment:2:1:enhLogHasErrors:10:8









Public Function enhLogHasErrors() As Boolean
	Dim result As Boolean
	
	On Error GoTo ErrorTrap
	result = False
	If Not (enhLog_ Is Nothing) Then result = enhLog_.hasErrors
	
ExitPoint:	
	enhLogHasErrors = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False	
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint		
End Function 

'++LotusScript Development Environment:2:1:getDocItemText:11:8

%REM 
	Function getDocItemText
	Gets the item text for the specified Item name.
	
	@param source NotesDocument from which to get the item text.
	@param itemname$ String Name of the NotesItem text to retrieve.
	
	@return text for the specified item name.  Returns empty string ("") if document is nothing or item not found.		
%END REM
Function getDocItemText(source As NotesDocument, itemname$) As Variant
	Dim extendedInfo As String	
	Dim result As String	
	On Error GoTo ErrorTrap
	
	Dim values As Variant
	result$ = || 	
	
	If source Is Nothing Then GoTo ExitPoint
	extendedInfo$ = |Item Name: | & itemname$

	values = source.GetItemValue(itemname$)
	If (UBound(values) > 0) Then 
		result$ = Trim$(source.GetFirstItem(itemname$).Text)	
	Else
		result$ = Trim$(CStr(values(0)))
	End If '(UBound(values) > 0)
	
ExitPoint:
	getDocItemText = result$
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	result$ = ||
	Resume ExitPoint	
End Function  

'++LotusScript Development Environment:2:2:enhLogSetSendTo:2:8

Public Sub enhLogSetSendTo (source As Variant)
	Call getEnhLog()
	enhLog_.SendTo = source
End Sub 	

'++LotusScript Development Environment:2:1:getACLlevel:9:8
%REM
	Function getACLlevel
	Gets the string representation of an ACL level integer 
	
	@param acl% ACL Level 
	
	@return ACL Level name associated with acl% 
%END REM
Private Function getACLlevel(acl%) As String 
	Dim result$ 
	
	Select Case acl%
		Case 0: result$ = |NO ACCESS|
		Case 1: result$ = |Depositor|
		Case 2: result$ = |Reader|
		Case 3: result$ = |Author|
		Case 4: result$ = |Editor|
		Case 5: result$ = |Designer|
		Case 6: result$ = |Manager|
		Case Else: result$ = |ACCESS LEVEL UNKNOWN|
	End Select 
	
	getACLlevel = result$
End Function

'++LotusScript Development Environment:2:1:getEmptyDocumentCollection:8:8

%REM This function intentionally has NO ERROR TRAPPING.  
	Creates an empty NotesDocumentCollection from the source database.
	
	@param source NotesDatabase from within which to create the empty document collection.
	@return NotesDocumentCollection containing zero documents.
%END REM Any raised errors should be handled by the calling code.
Public Function getEmptyDocumentCollection (source As NotesDatabase) As NotesDocumentCollection
	
	Dim result As NotesDocumentCollection
	
	Set result = source.GetProfileDocCollection(|*INVALID*|)
	While (result.Count > 0)
		Call result.DeleteDocument(result.GetFirstDocument())
	Wend 
	
	Set getEmptyDocumentCollection = result	
End Function 

'++LotusScript Development Environment:2:1:enhLogGetSubject:2:8

Public Function enhLogGetSubject() As String
	enhLogGetSubject = ||
	If Not (enhLog_ Is Nothing) Then enhLogGetSubject = enhLog_.Subject
End Function  

'++LotusScript Development Environment:2:3:FILEPATH_ENHANCEDLOG_FILE Get:5:8
%REM
	Property Get FILEPATH_ENHANCEDLOG_FILE
	Gets the Filepath for the current Enhanced Log File
%END REM
Public Property Get FILEPATH_ENHANCEDLOG_FILE (prefix$) As String   
		On Error GoTo ErrorTrap
	
		Static result$
		
		Dim chunks As Variant 
		Dim subdirectory$ 
		
		Dim prefixinternal$
	
		' BEGIN CODE
		If isBlankString(result$) Then 
			chunks = Split(FILEPATH_LOGS_DEFAULT, DEFAULT_DELIMITER)
			result$ = getCurrentSession().getEnvironmentString(|Directory|, True) 
			ForAll subdir In chunks
				subdirectory$ = CStr(subdir) 
				If Not isBlankString(subdirectory$) Then result$ = checkCreateDirectory(result$, CStr(subdir))
				If isBlankString(result$) Then Error ERR_OPERATION_FAILED, MSG_OPERATION_FAILED 
			End ForAll
			
			If isBlankString(prefix$) Then prefixinternal$ = |enhLog_| Else prefixinternal$ = prefix$
			result$ = result$ & FILEPATH_DELIMITER & prefixinternal$ & Format$(Now, |yyyy-mm-ddThh.nn.ss.log|) 
		End If 
		
	ExitPoint: 
		FILEPATH_ENHANCEDLOG_FILE = result$
		Exit Property 
	ErrorTrap:
		On Error GoTo 0
		enhLogException LIB_PREFIX, ||
		Resume ExitPoint
End Property


'++LotusScript Development Environment:2:2:enhLogSetAutoSave:2:8

Public Sub enhLogSetAutoSave (source As Boolean)
	Call getEnhLog()
	enhLogExtendedContent LIB_PREFIX, |Setting AutoSave to | & CStr(source), _ 
	|Called by: | & GetThreadInfo(LIB_LSI_THREAD_CALLPROC) & |()|
	enhLog_.AutoSave = source
End Sub 

'++LotusScript Development Environment:2:1:enhLogGetCachedErrorCode:2:8

Public Function enhLogGetCachedErrorCode() As Integer
	enhLogGetCachedErrorCode = 0
	If Not (enhLog_ Is Nothing) Then enhLogGetCachedErrorCode = enhLog_.CachedErrorCode
End Function 

'++LotusScript Development Environment:2:1:enhLogGetMethodTicks:9:8

%REM
	Function getMethodTicks
	Returns the number of clock ticks for a calling methodname since last called.

	@param classname$: Prefix for the calling methodname.
	@return: Number of milliseconds since last called.
%END REM
Public Function enhLogGetMethodTicks(ByVal classname$) As Double
	Dim extendedInfo As String	
	Dim result As Double
	On Error GoTo ErrorTrap
	
	Dim callingmodule As String
	Dim callingmethod As String 
	Dim tag As String 

	TrimString classname$ 
	callingmodule$ = GetThreadInfo(LIB_LSI_THREAD_CALLMODULE)
	callingmethod$ = GetThreadInfo(LIB_LSI_THREAD_CALLPROC)	
	tag$ = UCase$(Trim$(callingmodule$ & classname$ & callingmethod$))

	result# = enhLogGetTaggedTicks(tag$)

ExitPoint:
	enhLogGetMethodTicks = result#
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	result# = 0
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:enhLogGetProgramName:2:8

Public Function enhLogGetProgramName() As String
	enhLogGetProgramName = ||
	If Not (enhLog_ Is Nothing) Then enhLogGetProgramName = enhLog_.ProgramName
End Function 

'++LotusScript Development Environment:2:1:enhLogResetDbLog:2:8

Public Function enhLogResetDbLog() As Boolean
	Dim result As Boolean
	Dim extendedInfo As String
	Dim programName As String
	Dim subject As String
	
	On Error GoTo ErrorTrap
	
	
	If Not (enhLog_ Is Nothing) Then
		programName$ = enhLog_.ProgramName
		subject$ = enhLog_.Subject
		result = enhLogAction(LIB_PREFIX, |Resetting the ENHLOG|)
		If (Not enhLog_.Save(True, False)) Then
			extendedInfo$ = |Unable to save log.|
			Error ERR_OPERATION_FAILED, MSG_OPERATION_FAILED
		End If 
		
		Delete enhLog_
		Set enhLog_ = Nothing
		
		Sleep(1) ' Forces log entry documents to have at least 1 second between creation timestamps.
	End If 
	
	If Not result Then 
		extendedInfo$ = |Error in prior instance of ENHLOG object.|
		Error ERR_OPERATION_FAILED, MSG_OPERATION_FAILED
	End If 

	Call getEnhLog()
	enhLog_.ProgramName = programName$
	enhLog_.Subject = subject$
	
ExitPoint:
	enhLogResetDbLog = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:enhLogException:11:8
%REM 
	Function enhLogException 
	
	Writes information about an Exception to the log if LogExceptions is enabled. 
	
	@param prefix$ Prefix information 
	@param description$ information to be written to the log. 
	
	@return Flag indicating if the information about the Exception was written to the log. 
%END REM
Public Function enhLogException (prefix$, description$) As Boolean
	Dim result As Boolean	
	On Error GoTo ErrorTrap
	
	Dim errcode As Integer
	Dim errline As Long
	Dim errmsg As String
	Dim methodname As String

	errcode% = Err()
	errline& = Erl()
	errmsg$ = Error()
	methodname$ = prefix$ & GetThreadInfo(LIB_LSI_THREAD_CALLPROC)
	
	Call getEnhLog()
	If Not enhLog_.LogErrors Then GoTo ExitPoint 

	enhLog_.LogException errcode%, errmsg$, errline& , methodname$, description$
	
	result = True	
	
ExitPoint:	
	enhLogException = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:enhLogAppendAsDocLink:2:8

Public Function enhLogAppendAsDocLink (source As NotesDocument, fieldname$, linkcomment$, hotspottext$) As Boolean
	Dim result As Boolean
	
	On Error GoTo ErrorTrap
	
	Call getEnhLog()
	result = enhLog_.AppendAsDocLink(source, fieldname$, linkcomment$, hotspottext$)
	
ExitPoint:	
	enhLogAppendAsDocLink = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False	
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:enhLogHasEntries:2:8

Public Function enhLogHasEntries() As Boolean
	Dim result As Boolean
	
	On Error GoTo ErrorTrap
	result = False
	If Not (enhLog_ Is Nothing) Then result = enhLog_.hasEntries
	
ExitPoint:	
	enhLogHasEntries = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False	
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint		
End Function  

'++LotusScript Development Environment:2:2:enhLogSetLogErrors:2:8

Public Sub enhLogSetLogErrors (source As Boolean)
	Call getEnhLog()
	enhLog_.LogErrors = source
End Sub 

'++LotusScript Development Environment:2:2:enhLogSetProgramName:2:8

Public Sub enhLogSetProgramName (source$)
	Call getEnhLog()
	enhLog_.ProgramName = source
End Sub 

'++LotusScript Development Environment:2:3:FILEPATH_DELIMITER Get:5:8
%REM
	Property Get FILEPATH_DELIMITER
	Gets the Filepath Delimiter for the current Operating System
%END REM
Private Property Get FILEPATH_DELIMITER As String   
	On Error GoTo ErrorTrap

	Static result$

	' BEGIN CODE
	If isBlankString(result$) Then 
		If (InStr(LCase(getCurrentSession.Platform), |windows|) > 0) Then 
			result$ = |\|
		Else 
			result$ = |/| 
		End If
	End If 
	
ExitPoint: 
	FILEPATH_DELIMITER = result$
	Exit Property 
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint
End Property


'++LotusScript Development Environment:2:2:enhLogAllDocItems:2:8

Public Sub enhLogAllDocItems (source As NotesDocument)
	On Error GoTo ErrorTrap
	
	
	If (source Is Nothing) Then Error ERR_PARAMETER_BLANK, MSG_PARAMETER_BLANK
	
	enhLogExtendedContent LIB_PREFIX, |Notes Item Values (Text)|, |UNID = | & _ 
	source.UniversalID
	
	ForAll nitm In source.Items
		If (nitm.Type = RICHTEXT) Then
			enhLogExtendedContent ||, ||, |[| & nitm.Name & |]  (RichText): | & _ 
			nitm.GetFormattedText(True, 0)
			
			enhLogExtendedContent ||, ||, ||
		Else
			enhLogExtendedContent ||, ||, |[| & nitm.Name & |]:  | & nitm.Text
		End If 
	End ForAll 	
	
	enhLogExtendedContent ||, ||, ||
	
ExitPoint:
	Exit Sub
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint
End Sub 

'++LotusScript Development Environment:2:1:enhLogGetCachedErrorMessage:2:8

Public Function enhLogGetCachedErrorMessage() As String
	enhLogGetCachedErrorMessage = ||
	If Not (enhLog_ Is Nothing) Then enhLogGetCachedErrorMessage = enhLog_.CachedErrorMessage
End Function 

'++LotusScript Development Environment:2:1:enhLogGetConfigItemNames:2:8

Public Function enhLogGetConfigItemNames() As Variant 
	Dim extendedInfo As String
	Static result(16) As String
	On Error GoTo ErrorTrap
	
	Static isLoaded As Boolean
	If (Not isLoaded) Then 
		result(0) = ITEMNAME_ENHLOG_YN_LOGACTIONS
		result(1) = ITEMNAME_ENHLOG_YN_LOGENABLED
		result(2) = ITEMNAME_ENHLOG_YN_LOGERRORS
		result(3) = ITEMNAME_ENHLOG_YN_LOGMETHODRESULTS
		result(4) = ITEMNAME_ENHLOG_YN_LOGSTACKEXCEPTIONS
		result(5) = ITEMNAME_ENHLOG_YN_LOGWARNINGS
		result(6) = ITEMNAME_ENHLOG_YN_LOCALECHO
		result(7) = ITEMNAME_ENHLOG_YN_AUTOSAVE
		result(8) = ITEMNAME_ENHLOG_YN_OVERWRITE
		result(9) = ITEMNAME_ENHLOG_YN_RESUMEONFAIL
		result(10) = ITEMNAME_ENHLOG_YN_INCLUDEMETHODNAMES
		result(11) = ITEMNAME_ENHLOG_TARGET_SERVER
		result(12) = ITEMNAME_ENHLOG_TARGET_FILEPATH
		result(13) = ITEMNAME_ENHLOG_PURGE_AGE
		result(14) = ITEMNAME_ENHLOG_YN_PURGEENABLED
		result(15) = ITEMNAME_ENHLOG_YN_PROFILINGENABLED
		result(16) = ITEMNAME_ENHLOG_PROFILEMETHODCOUNT
		isLoaded = True
	End If 
	
ExitPoint:
	enhLogGetConfigItemNames = result
	Exit Function 
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:2:enhLogSetSubject:2:8

Public Sub enhLogSetSubject(source$)
	Call getEnhLog()
	enhLog_.Subject = source
End Sub 

'++LotusScript Development Environment:2:1:getOpenDatabase:9:8
%REM 
	Attempts to open a database.  
	
	@param server$ Name of server containing the database. 
	@param filepath$ Filepath for the database to open. 
	
	@return An opened database object as specified by the server and filepath.  Nothing if the database cannot be found or opened.
%END REM
Public Function getOpenDatabase(server$, filepath$) As NotesDatabase
	Dim extendedInfo As String
	Dim result As NotesDatabase
	On Error GoTo ErrorTrap
	
	Static nonDbs List As Boolean
		
	Dim sfKey As String
	
	TrimString server$
	TrimString filepath$
	extendedInfo$ = |Server: | & server$ & Chr(10) & |Filepath: | & filepath$
	
	sfKey$ = LCase$(Trim$(server$ & |!!| & filepath$))
	
	Set result = Nothing
	If IsElement(nonDbs(sfKey$)) Then GoTo ExitPoint
	
	Set result = New NotesDatabase(server$, filepath$)
	If (Not result.IsOpen) Then Call result.Open(server$, filepath$)
	If (Not result.isOpen) Then Error ERR_DATABASE_NOTOPEN, MSG_DATABASE_NOTOPEN
	
ExitPoint:
	If (result Is Nothing) Then nonDbs(sfKey$) = True
	Set getOpenDatabase = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	If Not (enhLog_ Is Nothing) Then enhLogException LIB_PREFIX, extendedInfo$
	Set result = Nothing
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:enhLogWarning:4:8



Public Function enhLogWarning (prefix$, description$) As Boolean
	Dim result As Boolean
	
	On Error GoTo ErrorTrap
	
	Call getEnhLog()
	If enhLog_.ActionsIncludeMethodNames Then
		enhLog_.LogWarning prefix$ & GetThreadInfo(LIB_LSI_THREAD_CALLPROC) & |(): | & description$
	Else
		enhLog_.LogWarning prefix$ & description$
	End If 
	
	result = True
	
ExitPoint:	
	enhLogWarning = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False	
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:strBeginsWith:9:8
%REM
	Function strBeginsWith
	Indicates if a String begins with another String 
	
	@param searchin$ The string to check for begins with with searchfor$
	@param searchfor$ The string with searchin$ needs to begin with
	@return Flag indicating if searchin$ begin with searchfor$
%END REM
Public Function strBeginsWith(searchin$, searchfor$) As Boolean 
	On Error GoTo ErrorTrap
	
	' exception variables
	Dim extendedinfo List As String 
	Dim msg$

	Dim result As Boolean
	
	extendedinfo(|searchin|) = searchin$
	extendedinfo(|searchfor|) = searchfor$
	
	result = (0 = StrComp(searchfor$, Left(searchin$, Len(searchfor$)), 5))
	
ExitPoint: 
	strBeginsWith = result
	Exit Function 
ErrorTrap:
	On Error GoTo 0
	ForAll s In extendedinfo
		If isBlankString(msg$) Then 
			msg$ = ListTag(s) & |: | & s
		Else 
			msg$ = msg$ & Chr(10) & ListTag(s) & |: | & s
		End If
	End ForAll
	enhLogException LIB_PREFIX, msg$
	Resume ExitPoint
End Function

'++LotusScript Development Environment:2:1:getCurrentDb:6:8

%REM
	Function getCurrentDb
	Description: handle to current database.
%END REM
Public Function getCurrentDb() As NotesDatabase
	Static result As NotesDatabase
	Dim extendedInfo As String
	On Error GoTo ErrorTrap
	
	If (result Is Nothing) Then Set result = getCurrentSession().CurrentDatabase
	
ExitPoint:
	Set getCurrentDb = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	Set result = Nothing
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:enhLogOptionsProfileFieldNames:2:8

Private Function enhLogOptionsProfileFieldNames() As Variant
	Dim extendedInfo As String
	Dim result() As String
	On Error GoTo ErrorTrap
	
	ReDim result(9) As String
	result(0) = |ynLogEnabled|
	result(1) = |ynLogActions|
	result(2) = |ynIncludeMethodNames|
	result(3) = |ynLogErrors|
	result(4) = |ynLogStackExceptions|
	result(5) = |ynLogWarnings|
	result(6) = |ynLogMethodResults|
	result(7) = |ynLocalEcho|
	result(8) = |ynAutoSave|
	result(9) = |ynResumeOnFail|

	ExitPoint:
	enhLogOptionsProfileFieldNames = result
		Exit Function
	ErrorTrap:
		On Error GoTo 0
		enhLogException LIB_PREFIX, extendedInfo$
		ReDim result(0) As String
		Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:enhLogMethodResultWithLink:4:8



Public Function enhLogMethodResultWithLink (prefix$, description$, linkto As Variant, linkcomment$, HotSpotText$) As Boolean
	Dim extendedcontent$
	Dim result As Boolean
	
	On Error GoTo ErrorTrap

	Call getEnhLog()
	If Not enhLog_.LogMethodResults Then GoTo ExitPoint 
	
	If enhLog_.ActionsIncludeMethodNames Then
		extendedcontent$ = prefix$ & GetThreadInfo(LIB_LSI_THREAD_CALLPROC) & |(): | & description$
	Else
		extendedcontent$ = prefix$ & description$
	End If 
	
	enhLog_.LogMethodResultWithLink extendedcontent$, linkTo, linkcomment$, HotSpotText$
	enhLogExtendedContent ||, ||, ||
	
	result = True
	
ExitPoint:	
	enhLogMethodResultWithLink = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = Err()	
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint		
End Function 

'++LotusScript Development Environment:2:1:getFormPrefixForLogging:1:8
Public Function getFormPrefixForLogging(subform_prefix$) As String 
	On Error GoTo ErrorTrap
	
	Dim nuiwsp As NotesUIWorkspace 
	Dim nuidoc As NotesUIDocument 
	Dim ndoc As NotesDocument 
	Dim nitm As NotesItem 
	
	Static result$
	Static form$
	
	If isBlankString(result) Then 
		If isBlankString(form$) Then 
			Set nuiwsp = New NotesUIWorkspace()
			Set nuidoc = nuiwsp.CurrentDocument
			Set ndoc = nuidoc.Document 
			If Not (ndoc Is Nothing) Then 
				If ndoc.HasItem(|Form|) Then 
					Set nitm = ndoc.GetFirstItem(|Form|)
					form$ = nitm.Text
				End If
			End If
			
			If Not isBlankString(form$) Then result$ = form$ & |.|
		End If
		
		result$ = result$ & subform_prefix$
	End If
	
ExitPoint: 
	getFormPrefixForLogging = result$
	Exit Function 
ErrorTrap:
	On Error GoTo 0
	enhLogException ||, ||
	Resume ExitPoint 
End Function 

'++LotusScript Development Environment:2:1:generateLogDoc:2:8

Private Function generateLogDoc(acl%, ndb As NotesDatabase, username As NotesName, userroles As Variant, start As NotesDateTime, progname$, server$, title$, filepath$, subject$, notesversion$, resumeonfail As Boolean) As NotesDocument
	Dim nnam As NotesName 
	Dim result As NotesDocument
	Dim nitm As NotesItem

	Dim accesslevel$
	Dim callingmethod$
	Dim msg$
	Dim msgtitle$

	Dim errmsg$ 
	Dim errcode%
	
	Static calldepth As Integer 
	
	On Error GoTo ErrorTrap
	
	calldepth = calldepth + 1 
	If (calldepth > 1) Then GoTo ExitPoint 
	
	If (ndb Is Nothing) Then Error ERR_PARAMETER_BLANK, MSG_PARAMETER_BLANK & |ndb Is Nothing| 
	If (username Is Nothing) Then Error ERR_PARAMETER_BLANK, MSG_PARAMETER_BLANK & |username Is Nothing| 
	If (start Is Nothing) Then Error ERR_PARAMETER_BLANK, MSG_PARAMETER_BLANK & |start Is Nothing| 

	accesslevel$ = getACLlevel(acl%) 
	
	Set result = New NotesDocument(ndb)
	If (result Is Nothing) Then Error ERR_OPERATION_FAILED, MSG_OPERATION_FAILED
	
	If (InStr(progname$, "|") > 0) Then
		subject$ = Trim$(StrRight(progname$, "|")) & | on (| & _ 
		server$ & |:| & filepath$ & |) at | & _ 
		start.LocalTime & | by | & username.Abbreviated
	Else
		subject$ = Trim$(progname$) & | on (| & _
		server$ & |:| & filepath$ & |) at | & _ 
		start.LocalTime & | by | & username.Abbreviated
	End If 		

	Set nitm = result.replaceItemValue(ITEMNAME_FORM, enhLogGetNotesLogForm())
	
%REM ***************************************************************************		|
 ************************************************************************************
	"SESSION" VARIABLES:
	A$AUTHORS
	A$PROGNAME, 
	A$USER, 
	A$SERVER, 
	A$LOGTIME, 
	A$DBTITLE, 
	A$DBFILEPATH, 
	A$DBREPID,
	A$USERACCESS,
	A$USERROLES,
	A$NOTESVERSION,
	VERSION
	
 ************************************************************************************
	%END REM *********************************************************************
	
	If result.hasItem(|A$AUTHORS|) Then Call result.removeItem(|A$AUTHORS|) 
	Set nitm = New NotesItem(result, |A$AUTHORS|, username.Canonical, AUTHORS)
	nitm.IsAuthors = True
	
	Set nitm = result.replaceItemValue(|A$PROGNAME|, progname$)
	Set nitm = result.replaceItemValue(|A$USER|, username.Abbreviated)
	Set nitm = result.replaceItemValue(|A$SERVER|, server$)
	Set nitm = result.replaceItemValue(|A$LOGTIME|, start)
	Set nitm = result.replaceItemValue(|A$DBTITLE|, title$)
	Set nitm = result.replaceItemValue(|A$DBFILEPATH|, filepath$)
	Set nitm = result.replaceItemValue(|A$DBREPID|, ndb.ReplicaID)
	Set nitm = result.replaceItemValue(|A$LOGID|, CStr(result.UniversalID))
	Set nitm = result.replaceItemValue(|$PublicAccess|, |1|) 	' allows Depositors to use object
	Set nitm = result.replaceItemValue(|A$USERACCESS|, accesslevel$)
	Set nitm = result.replaceItemValue(|A$USERROLES|, userroles)
	Set nitm = result.replaceItemValue(|VERSION|, VERSION)
	Set nitm = result.replaceItemValue(|SUBJECT|, subject$)  
	
	Set nitm = result.replaceItemValue(|A$NOTESVERSION|, notesversion$) 
	
	If enhLogOutputToNotesLog Then 
		Set nnam = New NotesName(getCurrentSession().EffectiveUserName) 
		Set nitm = result.replaceItemValue(|StartTime|, start) 
		Set nitm = result.replaceItemValue(|Server|, nnam.Abbreviated) ' poor choice of field names 
		Set nitm = result.replaceItemValue(|ExcludeFromView|, |A|) 
	End If
	
	' set all the items as summay
	ForAll nitmTmp In result.Items
		nitmTmp.IsSummary = True
	End ForAll 	
	
ExitPoint:
	If (errcode% <> 0) Then Error errcode%, errmsg$ 
	Set generateLogDoc = result
	calldepth = calldepth - 1
	Exit Function
ErrorTrap:
	On Error GoTo 0
	Set result = Nothing
	errcode% = Err() 
	errmsg$ = LIB_PREFIX & |generateLogDoc(): | & Error$() & |, Line #| & CStr(Erl())
	
	msgtitle$ = |Error | & CStr(Err()) & | at line: | & CStr(Erl())
	
	msg$ = LIB_PREFIX & |generateLogDoc()  | & _ 
	|Calling Method: | & GetThreadInfo(LIB_LSI_THREAD_CALLPROC) & _ 
	Chr(10) & |Call Depth: | & CStr(calldepth) & _ 
	Chr(10) & Error()
	
	If getCurrentSession().IsOnServer Then 
		MessageBox msgtitle$ & Chr(10) & msg$
	Else
		MessageBox msg$, 16, msgtitle$	
	End If 
	Resume ExitPoint 
End Function 

'++LotusScript Development Environment:2:1:enhLogGetCachedErrorMethod:2:8

Public Function enhLogGetCachedErrorMethod() As String
	enhLogGetCachedErrorMethod = ||
	If Not (enhLog_ Is Nothing) Then enhLogGetCachedErrorMethod = enhLog_.CachedErrorMethod
End Function 

'++LotusScript Development Environment:2:2:enhLogInstantiateNotesLog:19:8

%REM
	Sub enhLogInstantiateNotesLog
	Instantiates sets the properties (as specified in azlwConstants) for logging to log.nsf
	
	LOG OPTIONS controlled by Notes INI Variables
		
	ENHLOG_LOG_LEVEL
		OFF = 0  		<<< MUST EXPLICTLY SET 
		ERROR = 200 	<< DEFAULT : Logs Exceptions
		WARN = 300		: Logs Warnings and Exceptions
		INFO = 400 		: Logs Method Results, Warnings, and Exceptions
		TRACE = 600		: Logs Actions, Extended Content, Method Results, Warnings, and Exceptions 
	
	ENHLOG_LOCAL_ECHO=1 
		Causes all Log events to be echoed to the Notes Client status bar
	
%END REM
Sub enhLogInstantiateNotesLog() 
	On Error GoTo ErrorTrap
	
	' exception variables
	Dim extendedinfo List As String 
	Dim msg$
	
	Dim level$
	Dim localecho$ 
	
	
	' BEGIN CODE 
	enhLogSetLogErrors  True 
	enhLogSetActionsIncludeMethodNames True 
	enhLogSetLogWarnings False 		
	enhLogSetLogMethodResults False
	enhLogSetLogActions False
	enhLogSetLocalEcho False

	level$ = getCurrentSession().getEnvironmentString(|ENHLOG_LOG_LEVEL|, True)
	extendedInfo(|Level|) = level$ 
	Select Case level$ 
		Case |0|: 
			enhLogSetLogErrors  False 
			enhLogSetActionsIncludeMethodNames False 			
			
		Case |300|: 
			enhLogSetLogWarnings True 
			
		Case |400|: 
			enhLogSetLogWarnings True 
			enhLogSetLogMethodResults True 
			
		Case |600|: 
			enhLogSetLogWarnings True 
			enhLogSetLogMethodResults True 
			enhLogSetLogActions True 
	End Select
	
	localecho$ = getCurrentSession().getEnvironmentString(|ENHLOG_LOCAL_ECHO|, True)
	extendedInfo(|localecho|) = localecho$
	
	If (|1| = localecho$) Then 	enhLogSetLocalEcho True 

	Call getEnhLog()
	enhLog_.LogOutputToNotesLog = True ' write Log content to log.nsf
	Call enhLogReleaseVersionBuild()
	
	
ExitPoint: 
	Exit Sub 
ErrorTrap:
	On Error GoTo 0
	enhLogOutputToNotesLog = True ' write Log content to log.nsf
	ForAll s In extendedinfo
		If isBlankString(msg$) Then 
			msg$ = ListTag(s) & |: | & s
		Else 
			msg$ = msg$ & |, | & Chr(10) & ListTag(s) & |: | & s
		End If
	End ForAll
	enhLogException LIB_PREFIX, msg$
	Resume ExitPoint
End Sub

'++LotusScript Development Environment:2:1:getCallingUIobjectName:7:8
%REM
	Function getCallingUIobjectName
	gets the name of the calling UI element
	
	@return String Comments
%END REM
Private Function getCallingUIobjectName() As String
	Dim extendedInfo As String
	Dim result As String
	On Error GoTo ErrorTrap
	
	Dim nuiwsp As New NotesUIWorkspace()
	Dim view As NotesUIView
	Dim uidoc As NotesUIDocument
	Dim doc As NotesDocument
	Dim windowTitle As String
	
	result$ = ||
	If (Not getCurrentSession().isOnServer) Then 
		' Because a view can be embedded, need to check for it first.
		Set view = nuiwsp.CurrentView
		If (view Is Nothing) Then 
			' check for ui document
			Set uidoc = nuiwsp.CurrentDocument
			If (Not (uidoc Is Nothing)) Then 
				windowTitle$ = uidoc.WindowTitle
				Set doc = uidoc.Document
				If (doc Is Nothing) Then 
					result$ = |Page: | & windowTitle$
				Else
					If IsEmpty(doc.Items) Then
						result$ = |Page: | & windowTitle$
					ElseIf doc.HasItem(|Form|) Then
						result$ = |Form: | & Trim$(doc.GetFirstItem(|Form|).Text) & |.|
					Else
						result$ = |UIDoc: | & windowTitle$
					End If 
				End If 
			End If 
		Else
			' view is something
			result$ = Trim$(view.ViewAlias)
			If (Len(result$) > 0) Then 
				result$ = |View: | & view.ViewName & "|" & result$ & |.|
			Else
				result$ = |View: | & view.ViewName & |.|
			End If 
		End If 
	End If 
	
	If (Len(result$) = 0) Then result$ = ELEMENT_UNKNOWN	
		
	ExitPoint:
		getCallingUIobjectName = result$
		Exit Function
	ErrorTrap:
		On Error GoTo 0
		If Not (enhLog_ Is Nothing) Then enhLogException LIB_PREFIX, extendedInfo$
		result$ = ELEMENT_UNKNOWN
		Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:2:TrimString:6:8
%REM
	Removes leading and trailing spaces from a string.
	
	@param target$ String to be trimmed.	
%END REM
Public Sub TrimString (target$)
	target$ = Trim$(target$)
End Sub 

'++LotusScript Development Environment:2:1:strReplaceSubstring:13:8


%REM  THIS METHOD INTENTIONALLY HAS NO ERROR TRAPPING
	Function strReplaceSubstring 
	Replaces a substring with another string and returns the result
	
	@param source$  String within which to search 
	@param searchfor$ String to search for within source
	@replacewith String used to replace all instances of searchfor
	
	@return source with all instances of searchfor replaced with replacewith 
%END REM ERRORS MUST BE HANDLED BY CALLING CODE
Public Function strReplaceSubstring (source$, searchfor$, replacewith$) As String
	Dim result As String
	
	If isBlankString(searchfor$) Then
		strReplaceSubstring$ = source$
	Else
		If (InStr(source$, searchfor$) > 0) Then
			result$ = StrLeft(source$, searchfor$) & replacewith$ 
			result$ = result$ & strReplaceSubstring(StrRight(source$, searchfor$), searchfor$, replacewith$)
		Else 
			result$ = source$
		End If 
		
		strReplaceSubstring$ = result$
		
	End If 
End Function 

'++LotusScript Development Environment:2:2:enhLogSetCommonProperties:2:8

Public Sub enhLogSetCommonProperties(progname$, localEcho As Boolean, logActions As Boolean, logMethodResults As Boolean, logErrors As Boolean, logStackExceptions As Boolean)
	Dim extendedInfo As String
	On Error GoTo ErrorTrap
	Const SEARCHFOR = |Notes: Programmable Element Unknown|
	
	enhLogSetLocalEcho localEcho
	enhLogSetLogActions logActions
	enhLogSetLogMethodResults logMethodResults
	enhLogSetLogErrors logErrors	
	enhLogSetLogStackExceptions logStackExceptions
	If (Len(Trim(progname$)) > 0) Then enhLogSetProgramName progname$	
	
ExitPoint:
	Exit Sub
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	Resume ExitPoint
End Sub 

'++LotusScript Development Environment:2:2:enhLogSetLogActions:2:8

Public Sub enhLogSetLogActions (source As Boolean)
	Call getEnhLog()
	enhLog_.LogActions = source
End Sub 

'++LotusScript Development Environment:2:1:enhLogCreateLog:2:8

Public Function enhLogCreateLog (programName$) As EnhancedLog
	Call getEnhLog()
	enhLog_.ProgramName = programName$
	Set enhLogCreateLog = enhLog_
End Function 

'++LotusScript Development Environment:2:1:enhLogGetCachedErrorLine:7:8

%REM
	Public Function enhLogGetCachedErrorLine
	The Enhanced Log's Cached Error Line
	@return Integer
%END REM
Public Function enhLogGetCachedErrorLine() As Integer
	enhLogGetCachedErrorLine = 0
	If Not (enhLog_ Is Nothing) Then enhLogGetCachedErrorLine = enhLog_.CachedErrorLine
End Function 

'++LotusScript Development Environment:2:1:getEnvarName:11:8

%REM
	Function getEnvarName
	Constructs a valid Envirionment Variable Name from a given source string.
	
	@param source$: String from which to construct the Environment Variable NaMe.
	@param clearCache: Flag indicating if cached information should be cleared.
	
	@return	Environment Variable Name.  Blank on Error.	
%END REM
Function getEnvarName(source$, clearCache As Boolean) As String
	Dim extendedInfo As String
	Dim result As String

	On Error GoTo ErrorTrap
	
	Static cache List As String
	
	result$ = Trim$(source$)
	If (Len(result$) = 0) Then Error ERR_PARAMETER_BLANK, MSG_PARAMETER_BLANK
	If clearCache Then Erase cache
	If IsElement(cache(result$)) Then 
		result$ = cache(result$)
	Else
		cache(result$) = UCase$(strReplaceSubstring(result$, | |, |_|))
		result$ = cache(result$) 
	End If 
	
ExitPoint:
	getEnvarName = result$
	Exit Function
ErrorTrap:
	On Error GoTo 0
	extendedInfo$ = |Source: | & source$ & Chr(10) & |ClearCache: | & CStr(clearCache)
	enhLogException LIB_PREFIX, extendedInfo$
	result$ = ||
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:1:enhLogExtendedContentWithLink:16:8
%REM 
	Function enhLogExtendedContentWithLink
	
	Writes ExtendedContent information about an Action to the log if LogActions is enabled. 
	Appends a NotesLink to a NotesObject (Database, Document, or View) to the logged Action. 
	
	@param prefix$ Prefix information 
	@param description$ information to be written to the log. 
	@param extendedcontent$ Extended Content to be written. 
	@param linkTo Object for which to include a NotesLink in the log
	@param linkcomment$ Comment for the link
	@param HotSpotText$ HotSpotText for the link
	
	@return Flag indicating if ExtendedContent information about the Action was written to the log. 
%END REM
Public Function enhLogExtendedContentWithLink (prefix$, description$, extendedcontent$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$)  As Boolean
	Dim result As Boolean
	
	On Error GoTo ErrorTrap
	
	Call getEnhLog()
	If isBlankString(description$ & prefix$) Then 
		enhLog_.LogExtendedContentWithLink ||, extendedcontent$, linkTo, linkcomment$, HotSpotText$
	Else
		If enhLog_.ActionsIncludeMethodNames Then
			enhLog_.LogExtendedContentWithLink prefix$ & GetThreadInfo(LIB_LSI_THREAD_CALLPROC) & |(): | & description$, extendedcontent$, linkTo, linkcomment$, HotSpotText$
		Else
			enhLog_.LogExtendedContentWithLink prefix$ & description$, extendedcontent$, linkTo, linkcomment$, HotSpotText$
		End If 
	End If 
	
	result = True
	
ExitPoint:	
	enhLogExtendedContentWithLink = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = False
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:1:enhLogGetLogConfigDoc:2:8

Public Function enhLogGetLogConfigDoc(spawnNew As Boolean) As NotesDocument
	Dim extendedInfo As String
	Dim result As NotesDocument
	On Error GoTo ErrorTrap
	
	Dim killdoc As NotesDocument
	Dim nitm As NotesItem 
	Dim unid As String
	Dim fieldnames As Variant

	unid$ = enhLogGetLogConfigUNID() 
	extendedInfo$ = |UNID: | & unid$
	Set result = getDocumentByUNID(unid$) 
	If (result Is Nothing) Then
		Set killdoc = getLogOptionsProfile()
		If (killdoc Is Nothing) Then
			If spawnNew Then 
				Set result = New NotesDocument(getCurrentDb())
				result.UniversalID = unid$				
				Set nitm = result.ReplaceItemValue(|Form|, FORMNAME_ENHANCEDLOGCONFIG)
				nitm.IsSummary = True				
				If (Not result.Save(True, False)) Then Error ERR_DOC_NOT_SAVED, MSG_DOC_NOT_SAVED
			End If 	
		Else
			' killdoc is the deprecated log profile
			' spawnNew is ignored - replacing deprecated profile document with new config document
			Set result = New NotesDocument(getCurrentDb())
			result.UniversalID = unid$				
			Set nitm = result.ReplaceItemValue(|Form|, FORMNAME_ENHANCEDLOGCONFIG)
			nitm.IsSummary = True		

			fieldnames = enhLogOptionsProfileFieldNames()
			ForAll itemname In fieldnames
				If (killdoc.HasItem(itemname)) Then
					extendedInfo$ = |Item: | & itemname
					Set nitm = result.ReplaceItemValue(itemname, killdoc.GetFirstItem(itemname))
					nitm.IsSummary = True
				End If 
			End ForAll 
			
			If (Not result.Save(True, False)) Then Error ERR_DOC_NOT_SAVED, MSG_DOC_NOT_SAVED

			extendedInfo$ = |UNID: | & killdoc.UniversalID
			enhLogWarning LIB_PREFIX, |Removing Deprecated Log Profile document and replacing with Log Configuration document.|
			Call killdoc.Remove(True)
		End If 
	End If 
	
ExitPoint:
	Set enhLogGetLogConfigDoc = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	Set result = Nothing
	Resume ExitPoint
End Function  

'++LotusScript Development Environment:2:1:enhLogActionWithLink:17:8


%REM 
	Function enhLogActionWithLink
	
	Writes information about an Action to the log if LogActions is enabled. 
	Appends a NotesLink to a NotesObject (Database, Document, or View) to the logged Action. 
	
	@param prefix$ Prefix information 
	@param description$ information to be written to the log. 
	@param linkTo Object for which to include a NotesLink in the log
	@param linkcomment$ Comment for the link
	@param HotSpotText$ HotSpotText for the link
	
	@return Flag indicating if information about the Action was written to the log. 
%END REM
Public Function enhLogActionWithLink (prefix$, description$, linkTo As Variant, ByVal linkcomment$, ByVal HotSpotText$) As Boolean
	Dim extendedcontent$
	Dim result As Boolean

	On Error GoTo ErrorTrap

	
	Call getEnhLog()
	If Not enhLog_.LogActions Then GoTo ExitPoint 
	
	If enhLog_.ActionsIncludeMethodNames Then
		extendedcontent$ = prefix$ & GetThreadInfo(LIB_LSI_THREAD_CALLPROC) & |(): | & description$
	Else
		extendedcontent$ = prefix$ & description$
	End If 
	
	enhLog_.LogActionWithLink extendedcontent$, linkTo, linkcomment$, HotSpotText$
	
	result = True
	
ExitPoint:	
	enhLogActionWithLink = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	result = Err()	
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint	
End Function 

'++LotusScript Development Environment:2:2:enhLogSetLocalEcho:2:8

Public Sub enhLogSetLocalEcho (source As Boolean)
	Call getEnhLog()
	enhLog_.LocalEcho = source
End Sub 

'++LotusScript Development Environment:2:1:getCurrentSession:6:8

%REM
	Function getCurrentSession
	@return: handle to the current NotesSession
%END REM
Public Function getCurrentSession() As NotesSession
	Static result As NotesSession 

	On Error GoTo ErrorTrap
	If (result Is Nothing) Then Set result = New NotesSession()
	
ExitPoint:
	Set getCurrentSession = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, ||
	Set result = Nothing
	Resume ExitPoint
End Function 

'++LotusScript Development Environment:2:2:enhLogSetLogStackExceptions:2:8

Public Sub enhLogSetLogStackExceptions (source As Boolean)
	Call getEnhLog()
	enhLog_.LogStackExceptions = source
End Sub 

'++LotusScript Development Environment:2:2:enhLogClearCachedError:3:8


Public Sub enhLogClearCachedError()
	On Error GoTo ErrorTrap
	
	Call getEnhLog()
	Call enhLog_.ClearCachedError()
	
ExitPoint:
	Exit Sub
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, ||
	Resume ExitPoint
End Sub 

'++LotusScript Development Environment:2:2:enhLogSetLogMethodResults:2:8

Public Sub enhLogSetLogMethodResults (source As Boolean)
	Call getEnhLog()
	enhLog_.LogMethodResults = source
End Sub 

'++LotusScript Development Environment:2:1:enhLogIsProfilingEnabled:7:8

%REM
	Function enhLogIsProfilingEnabled

	@return Flag indicating if Method Profiling is Enabled
%END REM
Public Function enhLogIsProfilingEnabled() As Boolean 
	Dim extendedInfo As String
	Static result As Boolean
	On Error GoTo ErrorTrap

	Static isChecked As Boolean 
	
	If isChecked Then GoTo ExitPoint
	If (genhl_ProfiledMethods Is Nothing) Then Set genhl_ProfiledMethods = New ProfiledMethodList() 
	If (Not enhLogIsLogDisabled()) Then result = (|YES| = UCase$(enhLogGetLogConfigText(ITEMNAME_ENHLOG_YN_PROFILINGENABLED)))
	
	isChecked = True

ExitPoint:
	enhLogIsProfilingEnabled = result
	Exit Function
ErrorTrap:
	On Error GoTo 0
	enhLogException LIB_PREFIX, extendedInfo$
	result = False
	Resume ExitPoint
End Function 






































































































































